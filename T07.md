# T07-Ciclo de vida de la Activity y arquitectura MVVM

## √çndice

- [Introducci√≥n](#introducci√≥n)
- [Ejercicios](#ejercicios)
- [Conceptos clave del Codelab: La pizarra y la ventana](#conceptos-clave-del-codelab-la-pizarra-y-la-ventana)
- [`MutableStateFlow`: El Propietario del Estado](#mutablestateflow-el-propietario-del-estado)
- [`StateFlow`: El Observador del Estado](#stateflow-el-observador-del-estado)
- [El Patr√≥n Completo en `ViewModel` y `UI`](#el-patr√≥n-completo-en-viewmodel-y-ui)
- [¬øPor Qu√© esta Separaci√≥n? (El Flujo de Datos Unidireccional)](#por-qu√©-esta-separaci√≥n-el-flujo-de-datos-unidireccional)

## Introducci√≥n

El ciclo de vida de una aplicaci√≥n Android es bastante diferente al ciclo de vida de una aplicaci√≥n en otros S.O., como podr√≠a ser Windows. La mayor diferencia es que, en Android el ciclo de vida est√° controlado principalmente por el sistema y no directamente por el usuario.

![Activity Lifecycle](img/T07/activity_lifecycle.png)

Es importante entender qu√© ocurre en un dispositivo m√≥vil y lo peculiar del sistema operativo respecto a uno de escritorio como Windows.

Para ello vamos a ver los siguientes v√≠deos:

- [https://www.youtube.com/watch?v=stnLbKk0wak](https://www.youtube.com/watch?v=stnLbKk0wak)
- [https://www.youtube.com/watch?v=hbzzZ-orRWg](https://www.youtube.com/watch?v=hbzzZ-orRWg)

Para resolver la problem√°tica y que el usuario no pierda en ning√∫n momento su experiencia, el programador tiene que encargarse de evitar la p√©rdida de datos, para ello, disponemos de una serie de eventos que nos permite controlar el ciclo de vida de la Activity para que, por ejemplo:

- No falle si el usuario recibe una llamada telef√≥nica o cambia a otra app mientras usa la tuya.
- No consuma recursos valiosos del sistema cuando el usuario no la use de forma activa.
- No pierda el progreso del usuario si este abandona tu app y regresa a ella posteriormente.
- No falle ni pierda el progreso del usuario cuando se gire la pantalla entre la orientaci√≥n horizontal y la vertical.

Cada vez que una actividad cambia de estado se van a generar eventos que podr√°n ser capturados por ciertos m√©todos de la actividad. A continuaci√≥n, se muestra un esquema que ilustra los m√©todos que capturan estos eventos.

![Activity Lifecycle](img/T07/activity_lifecycle.png)

Puedes ver el siguiente v√≠deo para entender mejor el ciclo de vida: [https://www.youtube.com/watch?v=E1vAobJ8Fxo](https://www.youtube.com/watch?v=E1vAobJ8Fxo)

Ojo: No confundir el ciclo de vida de la Activity con el ciclo de vida del Composable, que es diferente aunque dependiente del primero. [https://developer.android.com/develop/ui/compose/lifecycle](https://developer.android.com/develop/ui/compose/lifecycle)

![Composable Lifecycle](img/T07/lifecycle-composition.png)

-----

## Ejercicios

Este es un tema muy complejo, por lo que vamos a hacerlo un poco m√°s **amigable** siguiendo el training oficial de Android: [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course). Esto corresponde con parte de la **Unit 4: Navigation and app architecture**.

De momento nos vamos a centrar s√≥lo en el **Pathway 1: Architecture components** [https://developer.android.com/courses/pathways/android-basics-compose-unit-4-pathway-1](https://developer.android.com/courses/pathways/android-basics-compose-unit-4-pathway-1) que ya tiene una duraci√≥n estimada m√°s que adecuada.

Cuando lleguemos a los codelabs, para traernos ese trabajo a nuestra organizaci√≥n, realizaremos la siguiente secuencia de acciones. B√°sicamente clonamos el repo oficial rama starter (que es la que nos piden), eliminamos su historial git, inicializamos un nuevo repo git, creamos el repo en nuestra organizaci√≥n y hacemos el primer push.

```bash
git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker
checkout starter
cd basic-android-kotlin-compose-training-dessert-clicker
git remote rename origin upstream
gh repo create YourMovilOrganization/YourRepoName --private --source=. --remote=origin
git push -u origin main
```

Ahora sin abandonar la terminal vamos a hacer un truco un poco üè¥‚Äç‚ò†Ô∏èpiratillaüè¥‚Äç‚ò†Ô∏è , no hag√°is esto en proyectos serios, pero para nuestras pr√°cticas es √∫til. Este truco borra la rama main original del codelab y crea una nueva main con el contenido del starter, de esta forma evitamos tener que hacer merges raros:

``` bash
git branch -D main
git checkout -b main
git add .
git commit -m "Initial commit from starter into main"
git push origin main
```

> [!NOTE]
> En PowerShell rm nos fallar√°. Siempre podemos borrar manualmente el .git o aprendernos su comando Remove-Item
> Recuerda tambi√©n los git config user.name y user.email si es necesario despu√©s del init

Este codelab nos servir√° tambi√©n para hacer la pr√°ctica de **Add a ViewModel to Dessert Clicker**.

> [!NOTE]
> Si bien con s√≥lo se pide entregar dos de los codelabs, es **totalmente imprescindible** realizar del de **ViewModel and State in Compose**.
> A nivel de contenidos es probablemente el m√°s importante.

### Conceptos clave del Codelab: La pizarra y la ventana

Imagina que tu `ViewModel` es como el aula del instituto, pero una con ventanas. Dentro del aula tenemos nuestra pizarra digital (el `MutableStateFlow`), y fuera del aula, tenemos una ventana de cristal (el `StateFlow`) a trav√©s de la cual los estudiantes que no han podido entrar al aula pueden ver lo que voy escribiendo.

1. **`MutableStateFlow` (La Pizarra Privada)** üìù

    - Es la pizarra **dentro** de nuestra aula (`ViewModel`).
    - Como es *nuestra* y es *mutable*, podemos **escribir** en ella, **borrar** y **actualizarlo** cuando queramos.
    - Contiene la "fuente de la verdad". Si el estado es "5 postres vendidos", eso es lo que aparece en la pizarra.
    - Nadie fuera del aula puede tocarlo. Es **privada**.

2. **`StateFlow` (La Ventana P√∫blica de "Solo Lectura")** ü™ü

    - Es una **ventana de cristal** que da al exterior (a la `UI` / Composable).
    - Cualquiera (la UI) puede **mirar** a trav√©s de la ventana y **ver** lo que aparece en la pizarra *en ese mismo instante*.
    - **No pueden escribir** a trav√©s de la ventana. Es de **solo lectura**.
    - Si cambiamos lo que aparece escrito y ponemos "6 postres vendidos", todos los que miran por la ventana ven "6 postres vendidos" inmediatamente.

Tu `ViewModel` usa el `MutableStateFlow` (la pizarra) para gestionar sus propios datos y expone un `StateFlow` (la ventana) para que la UI pueda reaccionar a esos datos sin poder modificarlos directamente.

-----

### `MutableStateFlow`: El Propietario del Estado

Es el **contenedor de estado mutable**. Su √∫nico trabajo es **mantener el valor del estado actual** y permitir que se **actualice**.

- **Caracter√≠stica Clave:** Es un "flujo caliente" (hot flow). Esto significa que **siempre tiene un valor**. Debes darle un valor inicial obligatorio.
- **Propiedad Principal:** `.value`.
  - Puedes **leer** el valor actual: `val contador = _miEstado.value`.
  - Puedes **escribir** (actualizar) el valor: `_miEstado.value = 10`.
- **Uso T√≠pico:** Se crea y se mantiene **privado** dentro del `ViewModel`. La convenci√≥n es usar un guion bajo (`_`) para marcarlo como privado.

**Ejemplo de creaci√≥n:**

```kotlin
// Dentro de tu ViewModel
// El estado inicial es 0
private val _contador = MutableStateFlow(0)
```

-----

### `StateFlow`: El Observador del Estado

Es la **vista inmutable (solo lectura)** del `MutableStateFlow`.

- **Caracter√≠stica Clave:** Expone el estado al mundo exterior (la UI) de forma segura.
- **Propiedad Principal:** `.value`.
  - Puedes **leer** el valor actual: `val contadorActual = miEstado.value`.
  - **NO PUEDES** escribir en √©l: `miEstado.value = 10` // \<-- ¬°Error de compilaci√≥n\!
- **En esteroides para la UI:** Cuando un Composable se suscribe (recolecta) a este flujo, recibe **inmediatamente el valor actual** y luego recibe autom√°ticamente cualquier actualizaci√≥n futura.

**Ejemplo de exposici√≥n:**

```kotlin
// Dentro de tu ViewModel
private val _contador = MutableStateFlow(0)

// Exponemos una versi√≥n p√∫blica de SOLO LECTURA
val contador: StateFlow<Int> = _contador.asStateFlow()
```

La funci√≥n `.asStateFlow()` es la que "crea la ventana" a partir de la "pizarra".

-----

### El Patr√≥n Completo en `ViewModel` y `UI`

Este es el rompecabezas completo, conectando `UiState` con `StateFlow`.

#### 1. El `ViewModel` (El Cerebro)

El `ViewModel` es el **due√±o** del estado. Usa `MutableStateFlow` para *gestionar* el estado y expone un `StateFlow` para que la UI lo *observe*.

```kotlin
// 1. Necesitar√°s de tu clase de estado
data class DessertUiState(
    // -----------------------------------------------------
    // PASO 0: Crear la Clase de Estado
    // Contiene todos los datos necesarios para dibujar la UI.
    // -----------------------------------------------------
    
    val revenue: Int = 0,
    val dessertsSold: Int = 0,
    // ...etc.
)

// 2. Y tambi√©n de tu ViewModel.
class DessertViewModel : ViewModel() {

    // ----------------------------------------------------
    // PASO 1: La pizarra (Privado y Mutable)
    // Contiene el estado completo de la pantalla.
    // ----------------------------------------------------
    private val _uiState = MutableStateFlow(DessertUiState()) // <-- Valor inicial


    // ----------------------------------------------------
    // PASO 2: La Ventana (P√∫blica y de Solo Lectura)
    // La UI observar√° esto.
    // ----------------------------------------------------
    val uiState: StateFlow<DessertUiState> = _uiState.asStateFlow()


    // ----------------------------------------------------
    // PASO 3: L√≥gica de Negocio (Eventos de la UI)
    // La UI llama a esta funci√≥n para "pedir" un cambio.
    // ----------------------------------------------------
    fun onDessertClicked() {
        
        // El ViewModel es el √∫nico que puede actualizar la pizarra
        _uiState.update { currentState ->
            // .update es seguro para concurrencia
            // .copy() crea un nuevo estado inmutable
            val newRevenue = currentState.revenue + 5 // O l√≥gica real
            val newDessertsSold = currentState.dessertsSold + 1
            
            currentState.copy(
                revenue = newRevenue,
                dessertsSold = newDessertsSold
            )
        }
    }
}
```

#### 2. El Composable (La Vista)

La UI **no posee estado**. Simplemente se suscribe al `StateFlow` del `ViewModel` y se redibuja cuando el estado cambia.

```kotlin
//3. Por √∫ltimo en la UI:
@Composable
fun DessertClickerApp(
    viewModel: DessertViewModel = viewModel() // Obtiene la instancia del ViewModel
) {
    // ----------------------------------------------------
    // PASO 4: Observar el Estado
    // .collectAsStateWithLifecycle() es la forma moderna y segura
    // de recolectar un StateFlow en Compose.
    // "uiState" aqu√≠ es una variable de estado de Compose.
    // ----------------------------------------------------
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    // ----------------------------------------------------
    // PASO 5: Dibujar la UI (Flujo de datos hacia abajo)
    // La UI es "tonta", solo dibuja lo que "uiState" le dice.
    // ----------------------------------------------------
    DessertClickerScreen(
        revenue = uiState.revenue,
        dessertsSold = uiState.dessertsSold,
        dessertImageId = uiState.currentDessertImageId,
        
        // ----------------------------------------------------
        // PASO 6: Notificar Eventos (Flujo de eventos hacia arriba)
        // Cuando el usuario hace clic, la UI no cambia el estado,
        // solo le "avisa" al ViewModel.
        // ----------------------------------------------------
        onDessertClicked = {
            viewModel.onDessertClicked() 
        }
    )
}
```

-----

> [!IMPORTANT]
> Si arrancais un proyecto de 0, ten√©is que importar las dependencias que se enumeran a continuaci√≥n, sino la llamada viewModel() fallar√°.

Esto en vuestro build.gradle.kts

```kotlin
     val lifecycle_version = "2.9.4"
        val arch_version = "2.2.0"

        // ViewModel
        implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version")
        // ViewModel utilities for Compose
        implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version")
```

Fuente para controlar latest versiones y otras librer√≠as del paquete: [https://developer.android.com/jetpack/androidx/releases/lifecycle#kts](https://developer.android.com/jetpack/androidx/releases/lifecycle#kts)

### ¬øPor Qu√© esta Separaci√≥n? (El Flujo de Datos Unidireccional)

Este patr√≥n se llama **Flujo de Datos Unidireccional (UDF)** y es la arquitectura central de Compose.

1. **Estado (State) fluye hacia abajo:**
    El `ViewModel` (due√±o del estado) env√≠a el `UiState` hacia la `UI`.
    *(VM -> UI)*

2. **Eventos (Events) fluyen hacia arriba:**
    La `UI` (clics, texto) env√≠a eventos al `ViewModel` para solicitar cambios.
    *(UI -> VM)*

Al usar `MutableStateFlow` (privado) y `StateFlow` (p√∫blico), **fuerzas** este patr√≥n. La UI *no puede* romper las reglas y modificar el estado directamente. Solo puede *pedirle* al `ViewModel` que lo haga.

Esto te da:

- **Seguridad:** El estado es coherente, ya que solo se modifica en un lugar (el VM).
- **Facilidad de Pruebas (Testing):** Puedes probar tu `ViewModel` por separado sin necesidad de una UI.
- **Depuraci√≥n Sencilla:** Sabes exactamente de d√≥nde vienen los cambios de estado.

![MVVM Flow](img/T07/mvvm.png)

üö© **TLDR - Entrega** üö©: La entrega consiste en un √∫nico repo en el que se completan los codelabs **Stages of the Activity lifecycle** y **Add a ViewModel to Dessert Clicker**. Es importante que la commit history sea clara y muestre el progreso del trabajo realizado.

En cualquier caso, se espera que realic√©is todos los codelabs de esta Unit 4, al menos del **Pathway 1: Architecture components**.
