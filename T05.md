# T05 - CheckBox, Slider, DropDown, RatingBar, FAB, Scaffold, SnackBar, Toast

## √çndice

- [Introducci√≥n](#introducci√≥n)

## Introducci√≥n

Vamos a ver otros componentes de la UI de usuario que nos permitir√°n introducir datos y realizaremos un ejercicio que los incluya a todos. **Como novedad en este tema vamos a trabajar en un √∫nico proyecto** y sobre este acumularemos todas nuestras soluciones como ficheros Kotlin. Vuestras plegarias (*lamentos*) han sido escuchadas, adem√°s que ten√©is raz√≥n que Android Studio tarda much√≠simo en buildear cada proyecto y es ineficiente.

Antes de arrancar, te comparto una web para que puedas consultar los componentes de Jetpack Compose Material 3, una de las librer√≠as m√°s usadas para crear interfaces de usuario en Android: [https://m3.material.io/components](https://m3.material.io/components)

## CheckBox

El `CheckBox` es un elemento muy parecido al `Switch` que ya vimos, pero con otra apariencia. Al igual que el `Switch`, necesita un `Text` para mostrar la etiqueta. Puedes ver un completo manual en: [https://www.develou.com/android-checkbox-en-compose/](https://www.develou.com/android-checkbox-en-compose/)

Tambi√©n podemos encontrarlo en la documentaci√≥n oficial de Jetpack Compose: [Checkbox](https://developer.android.com/develop/ui/compose/components/checkbox)

Recuerda que nosotros utilizaremos la **elevaci√≥n de estado** (**State Hoisting**) para manejar el estado de los controles.

-----

## Ejercicio 1

1. Crea un nuevo proyecto **Empty Activity** (Compose) llamado `T05Ejercicios`. Este lo vamos a usar a lo largo de todo este bloque de ejercicios.

    Indicando como `Package name` tu nombre, como muestra la imagen:

    ![Indicar Package name con tu nombre](img/T05/t05_project.png)

2. Activa el control de versiones (`VCS > Enable Version Control Integration...`) o `git init` en la terminal.
3. Realiza el git add . y el git commit -m "first commit" o cualquier mensaje similar.
4. Crea un nuevo repositorio en tu organizaci√≥n de GitHub con el mismo nombre y as√≥cialo.

> [!NOTE]
> Abajo el walkthrough con Github CLI. Hay que ejecutarlo desde el directorio del proyecto.

```bash
gh repo create ORGANIZACION/NOMBRE_REPO --private --source=. --remote=origin
git push -u origin main
```

Imagen con mi organizaci√≥n y proyecto (que no se llama exactamente igual pero bueno... se entiende la idea):
![Walkthrough creaci√≥n repo con GitHub CLI](img/T05/ghcli_turborepo.png)

5. Si no lo has hecho en el paso anterior, realiza ahora un push para comprobar que se sube correctamente.
6. Durante el progreso del ejercicio, realiza suficientes commits para que se vea la evoluci√≥n en el tiempo.
7. Crea un nuevo fichero de Kotlin llamado `T05Ejercicio1.kt`.

![Fichero Kotlin T05Ejercicio1](img/T05/kotlin_file_T05Ejercicio1.png)

8. Crea las funciones Composables para una pantalla de un pedido de pizza en el que:
    a. El pedido base vale **10 ‚Ç¨**.
    b. Permite a√±adir ingredientes a **2 ‚Ç¨** cada uno. Pon al menos 3 ingredientes, los que t√∫ prefieras, intenta ser original.
    c. Mostrar√° el total seg√∫n los ingredientes seleccionados.
    d. Mostrar√° las im√°genes de los ingredientes seleccionados.

![Pantalla de pedido de pizza](img/T05/pizza_app.png)

### Especificaciones

- La funci√≥n composable se encuentra en un fichero llamado `T05Ejercicio1.kt`.
- La UI deber√° cumplir con las indicaciones mostradas en la siguiente imagen:

![Especificaciones UI](img/T05/ejercicio01_ui_anotada.png)

- Busca unas im√°genes en Internet para los ingredientes e imp√≥rtalas a tu proyecto en la carpeta `drawable`.
- Las im√°genes se mostrar√°n centradas respecto al espacio que le quede de pantalla. Para ello, el `Row` donde ir√°n las im√°genes debe ocupar todo el espacio y centrar su contenido.
- Todo el texto que se muestre al usuario tiene que ir en `string.xml`, por ejemplo: `label = stringResource(R.string.queso)`.
- El c√≥digo tiene que estar minimamente documentado.
- Puedes a√±adir las mejoras visuales que desees. Por ejemplo, poner una imagen de una pizza de fondo de los ingredientes principales (acu√©rdate de `Box`).
- Puedes probar la funci√≥n en la `Activity` principal.
- Realiza commits que permitan ver la evoluci√≥n del proyecto y cuando termines el ejercicio, crea un commit llamado "fin ejercicio1".

> [!NOTE]
> Si te animas puedes crear una **tag** llamada `v1.0` para marcar la versi√≥n final del ejercicio 1.
> Esto es opciona, pero es una buena pr√°ctica para identificar hitos importantes en el desarrollo de un proyecto (aka versiones estables).

```bash
git tag v1.0
git push origin v1.0
```

-----

## Slider

El `Slider` es un control muy √∫til en aplicaciones m√≥viles para la introducci√≥n de datos num√©ricos limitados por rangos. Seguiremos el manual:
[https://www.develou.com/slider-en-compose/](https://www.develou.com/slider-en-compose/)

Tambi√©n podemos encontrarlo en la documentaci√≥n oficial de Jetpack Compose: [Slider](https://developer.android.com/develop/ui/compose/components/slider)

-----

## Ejercicio 2

9. A√±ade un fichero kotlin al proyecto anterior llamado `Ejercicio2.kt`.

![T05 estructura ejercicio2](img/T05/t05_structure_ejercicio2.png)

10. Crea un commit llamado "Inicio Ejercicio 2".

11. Crea las funciones Composables para una pantalla que permita elegir un color al usuario utilizando sliders.

![Ejercicio2 anotado](img/T05/ejercicio2_anotado.png)

Ten en cuenta que el `Slider` devuelve valores `Float`, pero la clase `Color` necesita `Int`. En Kotlin es sencillo hacer el cast:

    ```kotlin
    .background(Color(red.toInt(), green.toInt(), blue.toInt()))
    ```

12. Averigua c√≥mo crear las esquinas redondeadas.

13. Realiza commits que permitan ver la evoluci√≥n del proyecto y cuando termines el ejercicio, crea un commit llamado "fin Ejercicio2".

-----

## Men√∫ Desplegable (DropDown Menu)

![DropDown Menu Collapsed](img/T05/dropdown.png)

En Jetpack Compose con Material 3, para crear un men√∫ desplegable asociado a un campo de texto (similar a un `Spinner` tradicional o un `<select>` en HTML), se utiliza el componente `ExposedDropdownMenuBox`. Este composable envuelve un `TextField` (generalmente no editable) y el men√∫ desplegable (`ExposedDropdownMenu`) que aparece al interactuar con √©l. Los √≠tems individuales del men√∫ se definen con `DropdownMenuItem`.

Aunque existe un `DropdownMenu` m√°s gen√©rico, `ExposedDropdownMenuBox` es el componente espec√≠fico y recomendado cuando necesitas un selector desplegable vinculado visualmente a un campo de texto.

Para facilitar su reutilizaci√≥n, podemos encapsular esta l√≥gica en una funci√≥n composable personalizada. A continuaci√≥n, se muestra un ejemplo de c√≥mo crear un `DynamicSelectTextField` reutilizable:

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DynamicSelectTextField(
    selectedValue: String,
    options: List<String>,
    label: String,
    onValueChangedEvent: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }

    ExposedDropdownMenuBox(
        expanded = expanded,
        onExpandedChange = { expanded = !expanded },
        modifier = modifier
    ) {
        OutlinedTextField(
            readOnly = true, // El campo de texto no se edita directamente
            value = selectedValue,
            onValueChange = {}, // Vac√≠o porque es readOnly
            label = { Text(text = label) },
            trailingIcon = {
                // Icono que indica si el men√∫ est√° desplegado o no
                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
            },
            colors = OutlinedTextFieldDefaults.colors(), // Colores por defecto
            modifier = Modifier
                .menuAnchor() // Ancla el men√∫ al TextField
                .fillMaxWidth()
        )
        // El men√∫ desplegable en s√≠
        ExposedDropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false } // Acci√≥n al cerrar el men√∫
        ) {
            // Itera sobre las opciones para crear cada item del men√∫
            options.forEach { option: String ->
                DropdownMenuItem(
                    text = { Text(text = option) },
                    onClick = {
                        expanded = false // Cierra el men√∫
                        onValueChangedEvent(option) // Llama al callback con la opci√≥n seleccionada
                    }
                )
            }
        }
    }
}
```

**Par√°metros de `DynamicSelectTextField`:**

  * `selectedValue`: El valor (String) actualmente seleccionado, que se muestra en el `TextField`. Define el estado inicial.
  * `options`: Una lista de Strings (`List<String>`) que representan las opciones disponibles en el desplegable.
  * `label`: La etiqueta (String) que se muestra en el `OutlinedTextField`.
  * `onValueChangedEvent`: Una funci√≥n lambda `(String) -> Unit` que se invoca cuando el usuario selecciona una nueva opci√≥n. Recibe la opci√≥n seleccionada como par√°metro.
  * `modifier`: Un `Modifier` opcional para personalizar la apariencia o disposici√≥n del componente.

**Ejemplo de uso:**

```kotlin
@Composable
@Preview(showBackground = true)
fun EjemploDropdownMenu() {
    val options = listOf("Manzana", "Pl√°tano", "Fresa", "Naranja")
    // Estado para guardar la selecci√≥n actual
    var (seleccion, onValueChanged) = remember { mutableStateOf(options[0]) } // Opci√≥n por defecto

    Column(modifier = Modifier.padding(16.dp)) {
        DynamicSelectTextField(
            selectedValue = seleccion,
            options = options,
            label = "Fruta favorita",
            onValueChangedEvent = onValueChanged // Actualiza el estado al seleccionar
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text("Has seleccionado: $seleccion") // Muestra la selecci√≥n actual
    }
}
```

![DropDown Menu Expanded](img/T05/dropdown-expanded.png)

Trucazo ü§ô: Para mejorar la usabilidad, si la lista de `options` es muy larga, considera alternativas como un di√°logo de selecci√≥n con filtro de b√∫squeda o agrupar las opciones en submen√∫s si la l√≥gica lo permite. Esto evita que el usuario tenga que hacer un scroll excesivo.

## RatingBar

Permite que el usuario de forma visual pueda valorar o ver la valoraci√≥n de una entidad (pel√≠cula, m√∫sica, art√≠culo...). En estos momentos, no tenemos un componente espec√≠fico que lo represente, pero vamos a crear una funci√≥n sencilla que nos permita manejarlo.

La funci√≥n crea un `Row` con al menos 5 `Icon`. En funci√≥n del rating actual, se dibuja un icono relleno o hueco.

![Nota sobre bug Material3 y soluci√≥n con corazones](img/T05/nota-bug-material3.png)

La funci√≥n quedar√≠a como sigue:

```kotlin
/**
 * Rating bar composable
 * @param maxRating n√∫mero de estrellas
 * @param currentRating rating actual
 * @param onRatingChanged callback para cuando se cambia el rating
 * @param iconSelect icono para seleccionado
 * @param iconUnSelect icono para no seleccionado
 * @param modifier modificador
 * @param color color de las estrellas
 */
@Composable
fun RatingBar(
    maxRating: Int = 5,
    currentRating: Int,
    onRatingChanged: (Int) -> Unit,
    iconSelect: ImageVector = Icons.Filled.Star,
    iconUnSelect: ImageVector = Icons.Outlined.Star,
    modifier: Modifier = Modifier,
    color: Color = Color.Red
) {
    // 1. Aplica el modifier del par√°metro al componente ra√≠z (el Row)
    Row(modifier = modifier) {
        for (i in 1..maxRating) {
            Icon(
                imageVector = if (i <= currentRating) iconSelect else iconUnSelect,
                contentDescription = "Star $i",
                // 2. Crea un Modifier nuevo y local para cada Icon
                modifier = Modifier.clickable {
                    onRatingChanged(
                        if (i == 1 && currentRating == 1) 0 else i
                    )
                },
                tint = if (i <= currentRating) color else Color.Unspecified
            )
        }
    }
}
```

![RatingBar ejemplo uso](img/T05/ratingBar.png)

-----

## Floating Action Button (FAB)

El FAB es un bot√≥n para destacar la acci√≥n principal de una ventana en tu app.

![FAB ejemplo](img/T05/fab.png)

Podemos ver los detalles de uso en Material.io:
[https://m3.material.io/components/floating-action-button/overview](https://m3.material.io/components/floating-action-button/overview)

Y en Develou tenemos un buen manual:
[https://www.develou.com/floating-action-button-en-compose/](https://www.develou.com/floating-action-button-en-compose/)

-----

## Scaffold

En Material Design, un `Scaffold` es una estructura fundamental que proporciona una plataforma estandarizada para interfaces de usuario complejas. Une diferentes partes de la IU, como barras de la app y botones de acci√≥n flotantes.

![Scaffold ejemplo](img/T05/scaffold.png)

Cuando creamos un nuevo proyecto, la `Activity` est√° montada por defecto sobre la funci√≥n composable `Scaffold`.

Si nos fijamos en sus par√°metros, podemos a√±adir `topBar`, `bottomBar`, `floatingActionButton` y `snackbarHost`.

Aqu√≠ puedes ver lo que es el snackbar [snackbar m3](https://m3.material.io/components/snackbar/overview)

-----

## Ejercicio 3

14. Realiza commit "Inicio ejercicio 3".

15. A√±ade a la funci√≥n `Scaffold` desde su correspondiente par√°metro una `TopBar`.

    ```kotlin
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        topBar = {
            TopAppBar(title = { Text(text = stringResource(R.string.app_name)) })
        }
    ) { innerPadding ->
        //...
    }
    ```

16. Prueba que funciona.

17. Saca a una funci√≥n Composable propia llamada `App()` el `Scaffold`.

    ```kotlin
    class MainActivity : ComponentActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            enableEdgeToEdge()
            setContent {
                T05OtrosComponentesTheme {
                    App()
                }
            }
        }
    }

    @OptIn(ExperimentalMaterial3Api::class)
    @Composable
    fun App() {
        //... Scaffold va aqu√≠
    }
    ```

18. El objetivo es poder elegir el **Ejercicio1** y el **Ejercicio2** desde una lista desplegable.

* Mostrar√° en la `TopBar` el ejercicio actual.

![TopBar y Dropdown ejemplo](img/T05/topbar_y_dropdown.png)

* Cuando pulsemos sobre el `FloatingActionButton`, mostrar√° un mensaje con tu nombre y el ejercicio actual.

![Snackbar mostrando mensaje](img/T05/snackbar.png)

19. Deber√°s tener elevado el estado de la lista desplegable.

20. Los elementos de la lista desplegable tienen que guardarse como un array de string en `strings.xml`.

    ```xml
    <string-array name="opciones">
        <item>Ejercicio1</item>
        <item>Ejercicio2</item>
    </string-array>
    ```

    Y recuperarlos en la funci√≥n **App**: `val opciones = stringArrayResource(R.array.opciones).toList()`

21. Crea un nuevo fichero kotlin donde copias el m√©todo para crear listas desplegables que hemos visto antes (`DynamicSelectTextField`).

22. El estado de la lista lo necesitamos para el t√≠tulo y el mensaje, por lo que se tiene que elevar hasta la funci√≥n `App`.

    ```kotlin
    fun App() {
        val opciones = stringArrayResource(R.array.opciones).toList()
        var (ejercicioActual, onValueChangeEjercicio) = remember { mutableStateOf(opciones[0]) }
        //...
    }
    ```

23. Crea un m√©todo Composable llamado `Body` que muestre el contenido principal (lista y ejercicio) y ll√°malo desde el `Scaffold`.

    ```kotlin
    Scaffold(...) { innerPadding ->
        Body(opciones, ejercicioActual, onValueChangeEjercicio, Modifier.padding(innerPadding))
    }
    ```

    Este m√©todo `Body` mostrar√° la lista desplegable y, en funci√≥n del elemento elegido, mostrar√° el Ejercicio 1 o el Ejercicio 2.

-----

## Mensajes r√°pidos al usuario

### Toast

Un `Toast` proporciona informaci√≥n simple sobre una acci√≥n en una peque√±a ventana emergente que desaparece autom√°ticamente.

![Ejemplo de Toast](img/T05/toast.png)

24. En el m√©todo `Body`, a√±ade la siguiente llamada al final para que se muestre un `Toast` al cambiar de ejercicio:

    ```kotlin
    Toast.makeText(LocalContext.current, "Has elegido $ejercicioActual", Toast.LENGTH_SHORT).show()
    ```

Prueba que funciona.

![Toast mostrando mensaje](img/T05/toast_mensaje.png)

### Snackbar

El `Snackbar` es una barra inferior que sirve para mostrar un mensaje al usuario y/o tomar alguna acci√≥n. Se gestiona a trav√©s del `Scaffold`. Necesita ser lanzado en una Corrutina (hilo ligero de Kotlin), que veremos m√°s adelante. Manual muy completo en [https://www.develou.com/scaffold-en-jetpack-compose/](https://www.develou.com/scaffold-en-jetpack-compose/)

25. En tu funci√≥n `App`, define las variables de estado necesarias para manejar el `Snackbar`.

    ```kotlin
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    ```

26. Define un `SnackbarHost` en el `Scaffold`.

    ```kotlin
    Scaffold(
        //...
        snackbarHost = {
            SnackbarHost(snackbarHostState)
        },
        //...
    )
    ```

27. Muestra el mensaje agregando un `FloatingActionButton` al `Scaffold`.

    ```kotlin
    floatingActionButton = {
        FloatingActionButton(onClick = {
            //muestra el SnackBar desde un hilo
            scope.launch {
                snackbarHostState.showSnackbar(
                    message = "Jose Antonio L√≥pez: $ejercicioActual",
                    duration = SnackbarDuration.Short
                )
            }
        }) {
            Icon(Icons.Filled.Favorite, contentDescription = "Mostrar Snackbar")
        }
    }
    ```

28. Prueba que funciona.

29. Realiza un commit llamado "fin ejercicio 3" o similar. Y si ya te animas a crear una tag `v3.0` para marcar la versi√≥n final del ejercicio 3, pues mejor que mejor.

> ![NOTE]
> Si tiras por la tag, recuerda que adem√°s de crearla hay que subirla al repositorio remoto:

```bash
git tag v3.0
git push origin v3.0
```


-----

### Entrega:

  * Ordena y documenta el c√≥digo.
  * Entrega los enlaces a GitHub a los dos proyectos trabajados.
  * Recuerda que todo el texto tiene que estar en `String.xml`.
