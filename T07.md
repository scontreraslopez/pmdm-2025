# T07-Ciclo de vida de la Activity y arquitectura MVVM

![Activity Lifecycle](img/T07/activity_lifecycle.png)

## Introducci贸n

El ciclo de vida de una aplicaci贸n Android es bastante diferente al ciclo de vida de una aplicaci贸n en otros S.O., como podr铆a ser Windows. La mayor diferencia es que, en Android el ciclo de vida est谩 controlado principalmente por el sistema y no directamente por el usuario.

Es importante entender qu茅 ocurre en un dispositivo m贸vil y lo peculiar del sistema operativo respecto a uno de escritorio como Windows.

Para ello vamos a ver los siguientes v铆deos:

* [https://www.youtube.com/watch?v=stnLbKk0wak](https://www.youtube.com/watch?v=stnLbKk0wak)
* [https://www.youtube.com/watch?v=hbzzZ-orRWg](https://www.youtube.com/watch?v=hbzzZ-orRWg)

Para resolver la problem谩tica y que el usuario no pierda en ning煤n momento su experiencia, el programador tiene que encargarse de evitar la p茅rdida de datos, para ello, disponemos de una serie de eventos que nos permite controlar el ciclo de vida de la Activity para que, por ejemplo:

* No falle si el usuario recibe una llamada telef贸nica o cambia a otra app mientras usa la tuya.
* No consuma recursos valiosos del sistema cuando el usuario no la use de forma activa.
* No pierda el progreso del usuario si este abandona tu app y regresa a ella posteriormente.
* No falle ni pierda el progreso del usuario cuando se gire la pantalla entre la orientaci贸n horizontal y la vertical.

Cada vez que una actividad cambia de estado se van a generar eventos que podr谩n ser capturados por ciertos m茅todos de la actividad. A continuaci贸n, se muestra un esquema que ilustra los m茅todos que capturan estos eventos.

![Activity Lifecycle](img/T07/activity_lifecycle.png)

Puedes ver el siguiente v铆deo para entender mejor el ciclo de vida: [https://www.youtube.com/watch?v=E1vAobJ8Fxo](https://www.youtube.com/watch?v=E1vAobJ8Fxo)

Ojo: No confundir el ciclo de vida de la Activity con el ciclo de vida del Composable, que es diferente aunque dependiente del primero. [https://developer.android.com/develop/ui/compose/lifecycle](https://developer.android.com/develop/ui/compose/lifecycle)

![Composable Lifecycle](img/T07/lifecycle-composition.png)

-----

## Ejercicios

Este es un tema muy complejo, por lo que vamos a hacerlo un poco m谩s **amigable** siguiendo el training oficial de Android: [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course). Esto corresponde con parte de la **Unit 4: Navigation and app architecture**.

De momento nos vamos a centrar s贸lo en el **Pathway 1: Architecture components** [https://developer.android.com/courses/pathways/android-basics-compose-unit-4-pathway-1](https://developer.android.com/courses/pathways/android-basics-compose-unit-4-pathway-1) que ya tiene una duraci贸n estimada m谩s que adecuada.

Cuando lleguemos a los codelabs, para traernos ese trabajo a nuestra organizaci贸n, realizaremos la siguiente secuencia de acciones. B谩sicamente clonamos el repo oficial rama starter (que es la que nos piden), eliminamos su historial git, inicializamos un nuevo repo git, creamos el repo en nuestra organizaci贸n y hacemos el primer push.

```bash
git clone --branch starter https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker
cd basic-android-kotlin-compose-training-dessert-clicker
rm -rf .git     
git init -b main
git add .
git commit -m "Initial commit from Codelab starter"
gh repo create Movil2025SergioContrerasLopez/basic-android-kotlin-compose-training-dessert-clicker --private --source=. --remote=origin
git push -u origin main
```
> [!NOTE]
> En PowerShell rm nos fallar谩. Siempre podemos borrar manualmente el .git o aprendernos su comando Remove-Item
> Recuerda tambi茅n los git config user.name y user.email si es necesario despu茅s del init

Este codelab nos servir谩 tambi茅n para hacer la pr谩ctica de **Add a ViewModel to Dessert Clicker**.

> [!NOTE]
> Si bien con s贸lo se pide entregar dos de los codelabs, es **totalmente imprescindible** realizar del de **ViewModel and State in Compose**.
> A nivel de contenidos es probablemente el m谩s importante.

### Conceptos clave del Codelab: La pizarra y la ventana

Imagina que tu `ViewModel` es como el aula del instituto, pero una con ventanas. Dentro del aula tenemos nuestra pizarra digital (el `MutableStateFlow`), y fuera del aula, tenemos una ventana de cristal (el `StateFlow`) a trav茅s de la cual los estudiantes que no han podido entrar al aula pueden ver lo que voy escribiendo.

1. **`MutableStateFlow` (La Pizarra Privada)** 

      * Es la pizarra **dentro** de nuestra aula (`ViewModel`).
      * Como es *nuestra* y es *mutable*, podemos **escribir** en ella, **borrar** y **actualizarlo** cuando queramos.
      * Contiene la "fuente de la verdad". Si el estado es "5 postres vendidos", eso es lo que aparece en la pizarra.
      * Nadie fuera del aula puede tocarlo. Es **privada**.

2.  **`StateFlow` (La Ventana P煤blica de "Solo Lectura")** 

      * Es una **ventana de cristal** que da al exterior (a la `UI` / Composable).
      * Cualquiera (la UI) puede **mirar** a trav茅s de la ventana y **ver** lo que aparece en la pizarra *en ese mismo instante*.
      * **No pueden escribir** a trav茅s de la ventana. Es de **solo lectura**.
      * Si cambiamos lo que aparece escrito y ponemos "6 postres vendidos", todos los que miran por la ventana ven "6 postres vendidos" inmediatamente.

Tu `ViewModel` usa el `MutableStateFlow` (la pizarra) para gestionar sus propios datos y expone un `StateFlow` (la ventana) para que la UI pueda reaccionar a esos datos sin poder modificarlos directamente.

-----

### `MutableStateFlow`: El Propietario del Estado

Es el **contenedor de estado mutable**. Su 煤nico trabajo es **mantener el valor del estado actual** y permitir que se **actualice**.

* **Caracter铆stica Clave:** Es un "flujo caliente" (hot flow). Esto significa que **siempre tiene un valor**. Debes darle un valor inicial obligatorio.
* **Propiedad Principal:** `.value`.
  * Puedes **leer** el valor actual: `val contador = _miEstado.value`.
  * Puedes **escribir** (actualizar) el valor: `_miEstado.value = 10`.
* **Uso T铆pico:** Se crea y se mantiene **privado** dentro del `ViewModel`. La convenci贸n es usar un guion bajo (`_`) para marcarlo como privado.

**Ejemplo de creaci贸n:**

```kotlin
// Dentro de tu ViewModel
// El estado inicial es 0
private val _contador = MutableStateFlow(0)
```

-----

### `StateFlow`: El Observador del Estado

Es la **vista inmutable (solo lectura)** del `MutableStateFlow`.

* **Caracter铆stica Clave:** Expone el estado al mundo exterior (la UI) de forma segura.
* **Propiedad Principal:** `.value`.
  * Puedes **leer** el valor actual: `val contadorActual = miEstado.value`.
  * **NO PUEDES** escribir en 茅l: `miEstado.value = 10` // \<-- 隆Error de compilaci贸n\!
* **En esteroides para la UI:** Cuando un Composable se suscribe (recolecta) a este flujo, recibe **inmediatamente el valor actual** y luego recibe autom谩ticamente cualquier actualizaci贸n futura.

**Ejemplo de exposici贸n:**

```kotlin
// Dentro de tu ViewModel
private val _contador = MutableStateFlow(0)

// Exponemos una versi贸n p煤blica de SOLO LECTURA
val contador: StateFlow<Int> = _contador.asStateFlow()
```

La funci贸n `.asStateFlow()` es la que "crea la ventana" a partir de la "pizarra".

-----

### El Patr贸n Completo en `ViewModel` y `UI`

Este es el rompecabezas completo, conectando `UiState` con `StateFlow`.

#### 1. El `ViewModel` (El Cerebro)

El `ViewModel` es el **due帽o** del estado. Usa `MutableStateFlow` para *gestionar* el estado y expone un `StateFlow` para que la UI lo *observe*.

```kotlin
// 1. Define tu clase de estado (隆esto ya lo hiciste!)
data class DessertUiState(
    val revenue: Int = 0,
    val dessertsSold: Int = 0,
    // ...etc.
)

// 2. Tu ViewModel
class DessertViewModel : ViewModel() {

    // ----------------------------------------------------
    // PASO 1: El Pizarr贸n (Privado y Mutable)
    // Contiene el estado completo de la pantalla.
    // ----------------------------------------------------
    private val _uiState = MutableStateFlow(DessertUiState()) // <-- Valor inicial


    // ----------------------------------------------------
    // PASO 2: La Ventana (P煤blica y de Solo Lectura)
    // La UI observar谩 esto.
    // ----------------------------------------------------
    val uiState: StateFlow<DessertUiState> = _uiState.asStateFlow()


    // ----------------------------------------------------
    // PASO 3: L贸gica de Negocio (Eventos de la UI)
    // La UI llama a esta funci贸n para "pedir" un cambio.
    // ----------------------------------------------------
    fun onDessertClicked() {
        
        // El ViewModel es el 煤nico que puede actualizar el pizarr贸n
        _uiState.update { currentState ->
            // .update es seguro para concurrencia
            // .copy() crea un nuevo estado inmutable
            val newRevenue = currentState.revenue + 5 // O l贸gica real
            val newDessertsSold = currentState.dessertsSold + 1
            
            currentState.copy(
                revenue = newRevenue,
                dessertsSold = newDessertsSold
            )
        }
    }
}
```

#### 2. El Composable (La Vista)

La UI **no posee estado**. Simplemente se suscribe al `StateFlow` del `ViewModel` y se redibuja cuando el estado cambia.

```kotlin
@Composable
fun DessertClickerApp(
    viewModel: DessertViewModel = viewModel() // Obtiene la instancia del ViewModel
) {
    // ----------------------------------------------------
    // PASO 4: Observar el Estado
    // .collectAsStateWithLifecycle() es la forma moderna y segura
    // de recolectar un StateFlow en Compose.
    // "uiState" aqu铆 es una variable de estado de Compose.
    // ----------------------------------------------------
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    // ----------------------------------------------------
    // PASO 5: Dibujar la UI (Flujo de datos hacia abajo)
    // La UI es "tonta", solo dibuja lo que "uiState" le dice.
    // ----------------------------------------------------
    DessertClickerScreen(
        revenue = uiState.revenue,
        dessertsSold = uiState.dessertsSold,
        dessertImageId = uiState.currentDessertImageId,
        
        // ----------------------------------------------------
        // PASO 6: Notificar Eventos (Flujo de eventos hacia arriba)
        // Cuando el usuario hace clic, la UI no cambia el estado,
        // solo le "avisa" al ViewModel.
        // ----------------------------------------------------
        onDessertClicked = {
            viewModel.onDessertClicked() 
        }
    )
}
```

-----

### 驴Por Qu茅 esta Separaci贸n? (El Flujo de Datos Unidireccional)

Este patr贸n se llama **Flujo de Datos Unidireccional (UDF)** y es la arquitectura central de Compose.

1. **Estado (State) fluye hacia abajo:**
    El `ViewModel` (due帽o del estado) env铆a el `UiState` hacia la `UI`.
    *(VM -> UI)*

2. **Eventos (Events) fluyen hacia arriba:**
    La `UI` (clics, texto) env铆a eventos al `ViewModel` para solicitar cambios.
    *(UI -> VM)*

Al usar `MutableStateFlow` (privado) y `StateFlow` (p煤blico), **fuerzas** este patr贸n. La UI *no puede* romper las reglas y modificar el estado directamente. Solo puede *pedirle* al `ViewModel` que lo haga.

Esto te da:

* **Seguridad:** El estado es coherente, ya que solo se modifica en un lugar (el VM).
* **Facilidad de Pruebas (Testing):** Puedes probar tu `ViewModel` por separado sin necesidad de una UI.
* **Depuraci贸n Sencilla:** Sabes exactamente de d贸nde vienen los cambios de estado.

 **TLDR - Entrega** : La entrega consiste en un 煤nico repo en el que se completan los codelabs **Stages of the Activity lifecycle** y **Add a ViewModel to Dessert Clicker**. Es importante que la commit history sea clara y muestre el progreso del trabajo realizado.

En cualquier caso, se espera que realic茅is todos los codelabs de esta Unit 4, al menos del **Pathway 1: Architecture components**.
