<!-- markdownlint-disable MD029 -->

# T11 ‚Äì Integraci√≥n de APIs con Retrofit y Coroutines. Manejo de Intents en Android

## 1. El sistema de mensajer√≠a de Android: Intents

En el desarrollo nativo, los componentes de una aplicaci√≥n (como las *Activities* o los *Services*) no se invocan directamente instanciando sus clases. Android utiliza un **sistema de mensajer√≠a as√≠ncrona** llamado **Intent**. Un `Intent` es una descripci√≥n abstracta de una operaci√≥n que se va a realizar.

Seg√∫n el curr√≠culo oficial, debemos dominar las clases necesarias para la conexi√≥n y comunicaci√≥n, y los Intents son la piedra angular para ello. Esta secci√≥n cubrir√° los aspectos esenciales de los Intents en Android, no pretende ser un curso exhaustivo (como en casi todo hay mucho m√°s y mejor), pero s√≠ darte las bases para que puedas utilizarlos eficazmente en tus aplicaciones.

### 1.1. Tipos de Intents

Podemos clasificar los Intents en dos grandes grupos seg√∫n su prop√≥sito y especificidad:

#### A. Intents Expl√≠citos

Se utilizan para iniciar un componente espec√≠fico dentro de tu propia aplicaci√≥n. Se denominan "expl√≠citos" porque defines exactamente qu√© clase (Activity o Service) quieres arrancar. Son la base de la navegaci√≥n cl√°sica en Android.

**Ejemplo: Navegar de la `MainActivity` a `DetailActivity`**

```kotlin
val intent = Intent(this, DetailActivity::class.java)
startActivity(intent)
```

> [!NOTE]
> Esto lo ver√°s sobre todo si tienes la ¬øsuerte? de trabajar con proyectos legacy (view system / XML) o con c√≥digo Java antiguo. En proyectos modernos con Jetpack (**Navigation Compose**), la navegaci√≥n entre pantallas se gestiona con los Navigation Components que hemos visto (aunque los Intents expl√≠citos siguen siendo v√°lidos y √∫tiles en muchos casos).

#### B. Intents Impl√≠citos

No nombran un componente espec√≠fico, sino que declaran una **acci√≥n general** a realizar. El sistema Android busca entre todas las aplicaciones instaladas aquellas que tengan un *Intent Filter* capaz de manejar dicha acci√≥n. Esto es crucial para integrar nuestra app con el ecosistema (abrir mapas, compartir texto, hacer una llamada, etc.).

Como imaginar√°s, estos Intents son fundamentales para nosotros a la hora de consumir los servicios de otras apps o del sistema.

**Ejemplo: mandar un texto:**

```kotlin
    // Acci√≥n: ENVIAR algo (SEND)
    val sendIntent = Intent(Intent.ACTION_SEND).apply {
        // Importante: Definir el tipo de dato (MIME type)
        type = "text/plain"
        // El contenido a compartir
        putExtra(Intent.EXTRA_TEXT, "¬°Mira la nueva app del instituto! Desc√°rgala aqu√≠.")
    }

    // createChooser crea el men√∫ visual para elegir app (WhatsApp, Gmail, etc.)
    // y adem√°s protege si no hay ninguna app (aunque es raro no tener ninguna).
    val shareIntent = Intent.createChooser(sendIntent, "Compartir v√≠a...")
    context.startActivity(shareIntent)
```

#### C. Resumen de los tipos de Intents (TLDR)

Es importante aclarar la diferencia entre ambos tipos de Intents en funci√≥n del contexto de uso, dado que la evoluci√≥n de Android ha cambiado la forma en que navegamos entre pantallas. ¬°Android evoluciona rapid√≠simo y hay que estar al d√≠a!  

**Navegaci√≥n Interna (Dentro de tu App)**:

- En el pasado (Legacy/View System): Se usaban Intents Expl√≠citos para saltar de una pantalla a otra (de Activity a Activity). Era pesado y lento.
- En el presente (Jetpack Compose): Usamos Navigation Compose. Google recomienda una arquitectura de "Activity √önica" (Single Activity Architecture), donde la navegaci√≥n entre pantallas se gestiona intercambiando funciones `@Composable` de forma fluida dentro de la misma ventana, sin usar Intents.

**Navegaci√≥n Externa (Hacia otras Apps)**:

- Aqu√≠ los Intents (Impl√≠citos) siguen siendo los reyes indiscutibles. Da igual que uses tecnolog√≠a moderna o antigua; si quieres abrir la c√°mara, el mapa o compartir un texto con WhatsApp, necesitas un Intent.

### 1.2. Transferencia de datos entre Activities (Extras)

Un `Intent` puede transportar datos adicionales utilizando el m√©todo `putExtra()`, que funciona como un mapa de clave-valor. Estos datos se recuperan en la actividad de destino a trav√©s de `intent.extras`.

**Enviar datos:**

```kotlin
val intent = Intent(this, UserProfileActivity::class.java).apply {
    putExtra("USER_ID", 42)
    putExtra("USER_NAME", "Alice")
}
startActivity(intent)
```

**Recibir datos (en `UserProfileActivity`):**

```kotlin
val userId = intent.getIntExtra("USER_ID", -1) // -1 es el valor por defecto
val userName = intent.getStringExtra("USER_NAME")
```

### 1.3. Pr√°ctica guiada: IES Severo Ochoa Intents

Para practicar el uso de Intents, vamos a hacer una peque√±a aplicaci√≥n monopantalla del IES Severo Ochoa que nos permita:

- Abrir la web del instituto.
- Llamar por tel√©fono al instituto.
- Ver la ubicaci√≥n del instituto en Google Maps.
- Enviar un correo electr√≥nico al instituto.
- Calcular la distancia desde nuestra ubicaci√≥n actual al instituto.
- Mandar un WhatsApp al instituto.

> [!NOTE]
> Esto en el emulador funcionar√° bastante regular, os recomiendo utilizar vuestro dispositivo f√≠sico.

Empecemos clonando el proyecto base desde GitHub: [https://github.com/scontreraslopez/IESSeveroOchoaIntents](https://github.com/scontreraslopez/IESSeveroOchoaIntents)

Partimos de una interfaz gr√°fica ya construida (Scaffold), pero los botones est√°n "muertos". Nuestro objetivo es conectarlos con el sistema operativo Android para que realicen acciones reales: llamar, abrir mapas, enviar correos y, lo m√°s complejo, **geolocalizar al usuario**.

Usaremos **Intents Impl√≠citos** (pedir al sistema que haga algo por nosotros) y gestionaremos **Permisos en tiempo de ejecuci√≥n** (la forma segura y moderna de pedir datos sensibles como la ubicaci√≥n).

### 1.3.1. Paso 0: Los cimientos (Configuraci√≥n)

Antes de tocar el c√≥digo Kotlin, necesitamos preparar el terreno. Si intentamos usar mapas o ubicaci√≥n sin avisar a Android, la app fallar√°.

**Dependencias (Gradle):**

Para calcular la ubicaci√≥n, no usamos la API antigua de Android, sino los **Google Play Services** (m√°s precisos y eficientes con la bater√≠a).
Ve al archivo `build.gradle.kts (Module: app)` y aseg√∫rate de a√±adir esta l√≠nea en el bloque `dependencies`:

```kotlin
implementation("com.google.android.gms:play-services-location:21.3.0")
```

> **Nota:** Al a√±adir esto, aparecer√° una barrita arriba diciendo "Sync Now". Acu√©rdate de pulsarla para que Gradle descargue la librer√≠a.

**El Manifiesto (Permisos y Visibilidad):**

Abre `AndroidManifest.xml`. Tenemos que hacer dos cosas aqu√≠:

1. **Declarar permisos de uso:** "Oye Android, mi app es capaz de usar el GPS".
2. **Declarar visibilidad (`queries`):** Desde Android 11, las apps no pueden ver qu√© otras apps hay instaladas (por privacidad). Si queremos saber si WhatsApp existe, debemos pedir permiso para "preguntar".

Copia esto justo encima de la etiqueta `<application ...>`:

```xml
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>

    <queries>
        <package android:name="com.whatsapp" />
        <package android:name="com.google.android.apps.maps" />
    </queries>
```

-----

### 1.3.2. Paso 1: Abrir Web (LocalUriHandler)

Empezamos con lo f√°cil. En **Jetpack Compose**, abrir una URL es trivial gracias a `LocalUriHandler`.
Sit√∫ate al principio de la funci√≥n `IESSeveroOchoaIntents()`, donde est√°n las variables. Ver√°s que ya tienes definido:

```kotlin
    val context = LocalContext.current
    val uriHandler = LocalUriHandler.current // El "mago" que abre enlaces
    val webUrl = "https://portal.edu.gva.es/03013224/"
```

- **¬øQu√© es `LocalUriHandler`?** Es una herramienta de Compose que sabe "despachar" URIs. Si le das una web, abre el navegador. Si le das un tel√©fono, abre el marcador.

Ahora, ve al bot√≥n **"Web del Instituto"** y en su `onClick` a√±ade:

```kotlin
    uriHandler.openUri(webUrl)
```

¬°Listo! Android detectar√° el prefijo `https://` y buscar√° un navegador (Chrome) para abrirlo.

-----

### 1.3.3. Paso 2: Llamada Telef√≥nica (El esquema `tel:`)

Continuamos con el bot√≥n de **Llamar**. Aqu√≠ vamos a usar el mismo `uriHandler`, pero el truco est√° en la cadena de texto que le pasamos.
Las URIs funcionan por **esquemas**.

- Web -> `https://...`
- Tel√©fono -> `tel:...`

Busca el bot√≥n **"Llamar a Secretar√≠a"** y a√±ade:

```kotlin
    // El formato debe ser "tel:+3496..."
    uriHandler.openUri("tel:$phoneNumber")
```

> **Detalle:** F√≠jate en el prefijo `tel:`. Sin √©l, Android intentar√≠a abrirlo como una web y fallar√≠a.

-----

### 1.3.4. Paso 3: Google Maps (Codificaci√≥n y Query Strings)

Aqu√≠ la cosa se pone interesante. Queremos abrir Google Maps centrado en el instituto, con el zoom adecuado y una chincheta (marcador) con nombre.

Los Intent de mapas son "especialitos". Tienen este formato:
`geo:0,0?q=latitud,longitud(Nombre de la etiqueta)&z=zoom`

1. **¬øPor qu√© `geo:0,0`?** Le decimos al mapa "no te centres en ninguna coordenada inicial, c√©ntrate en lo que venga en la b√∫squeda (`q`)".
2. **El problema de los espacios:** La etiqueta "IES Severo Ochoa" tiene espacios. Las URLs **odian** los espacios. Si mandamos eso tal cual, el enlace se rompe.

**Soluci√≥n:** Usar `URLEncoder`.

Ve al bot√≥n **"Ver en Google Maps"** y completa el `TODO`:

```kotlin
    // 1. Codificamos el nombre para que sea seguro (los espacios se convierten en %20, etc.)
    // IMPORTANTE: Necesitar√°s importar java.net.URLEncoder
    val encodedLabel = URLEncoder.encode(mapLabel, "UTF-8")

    // 2. Construimos la URI compleja concatenando las variables
    val geoUri = "geo:0,0?q=$latitude,$longitude($encodedLabel)&z=$mapZoom"

    // 3. Lanzamos
    uriHandler.openUri(geoUri)
```

Ahora, al pulsar, Maps entender√° perfectamente d√≥nde ir y qu√© nombre mostrar.

-----

### 1.3.5. Paso 4: Email (El esquema `mailto:`)

Enviar un correo es similar. Usamos el esquema `mailto:`. Pero cuidado, el asunto (`subject`) y el cuerpo (`body`) tambi√©n pueden tener espacios y tildes. ¬°Hay que codificarlos!

Ve al bot√≥n **"Enviar Email"** y a√±ade:

```kotlin
    // Codificamos asunto y cuerpo
    val encodedSubject = URLEncoder.encode(emailSubject, "UTF-8")
    val encodedBody = URLEncoder.encode(emailBody, "UTF-8")

    // Construimos la URI
    val mailtoUri = "mailto:$emailRecipient?subject=$encodedSubject&body=$encodedBody"

    uriHandler.openUri(mailtoUri)
```

-----

### 1.3.6. Paso 5: WhatsApp (Intents manuales y Excepciones)

A veces `uriHandler` se queda corto o queremos m√°s control. Para WhatsApp, vamos a implementar una funci√≥n auxiliar `sendWhatsAppMessage` al final del archivo.

**Reto:** ¬øQu√© pasa si el usuario NO tiene WhatsApp instalado? Si intentamos abrirlo sin m√°s, la app se cerrar√° de golpe (crash). Debemos controlar ese error.

Ve a la funci√≥n `sendWhatsAppMessage` (al final del archivo) e implem√©ntala as√≠:

```kotlin
fun sendWhatsAppMessage(context: Context, phoneNumber: String, message: String) {
    // 1. Limpieza: WhatsApp quiere el n√∫mero sin '+' ni espacios (ej: 34666...)
    val cleanNumber = phoneNumber.replace("+", "").replace(" ", "")
    
    // 2. Codificamos el mensaje
    val encodedMessage = URLEncoder.encode(message, "UTF-8")
    
    // 3. Creamos la URI "m√°gica" de WhatsApp
    val uri = "https://wa.me/$cleanNumber?text=$encodedMessage"

    // 4. Creamos un Intent nativo ACTION_VIEW
    val intent = Intent(Intent.ACTION_VIEW)
    intent.data = android.net.Uri.parse(uri)

    /* TRUCO PRO: Si descomentas la siguiente l√≠nea, obligas a abrir WhatsApp oficial.
       Si la dejas comentada, Android preguntar√° al usuario (√∫til si usa WhatsApp Business) */
    // intent.setPackage("com.whatsapp")

    // 5. INTENTAMOS abrir la actividad
    try {
        context.startActivity(intent)
    } catch (e: ActivityNotFoundException) {
        // Si entramos aqu√≠, es que no tiene WhatsApp instalado
        Toast.makeText(context, "WhatsApp no est√° instalado", Toast.LENGTH_SHORT).show()
    }
}
```

Ahora conecta esta funci√≥n en el bot√≥n **"Mandar Whatsapp"** del Scaffold.

-----

### 1.3.7. Paso 6: Ubicaci√≥n y Permisos (lo m√°s complejo)

Esta es la parte m√°s compleja. La ubicaci√≥n se considera un **permiso peligroso**. No basta con ponerlo en el Manifest; hay que pedirle permiso al usuario mediante una ventana emergente (di√°logo) mientras usa la app.

**El "Launcher" de Permisos:**

En Compose, necesitamos registrar un "lanzador" que escuche la respuesta del usuario (¬øDijo S√ç o dijo NO?).
Ve al inicio de `IESSeveroOchoaIntents`, busca el **TODO Paso 5. Crear el permissionLauncher** y a√±ade:

```kotlin
    // Preparamos el escuchador de permisos
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        // Este c√≥digo se ejecuta CUANDO el usuario responde al di√°logo
        val isGranted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                        permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true

        if (isGranted) {
            Toast.makeText(context, "Permiso concedido. Calculando...", Toast.LENGTH_SHORT).show()
            // ¬°Llamamos a la funci√≥n que calcula!
            calculateAndShowDistance(context, latitude, longitude)
        } else {
            Toast.makeText(context, "Se necesita permiso para calcular la distancia", Toast.LENGTH_LONG).show()
        }
    }
```

**Entendiendo `rememberLauncherForActivityResult` (El concepto clave)**

Hasta ahora, nuestro c√≥digo era lineal: puls√°bamos un bot√≥n y se abr√≠a una web. Fin.
Pero los **Permisos** son diferentes. Es una conversaci√≥n de dos v√≠as:

1. Tu App pregunta: "¬øPuedo usar el GPS?"
2. Tu App **se queda esperando**.
3. El Usuario decide (puede tardar 1 segundo o 10 minutos).
4. Android vuelve a tu App con la respuesta: "S√≠" o "No".

Para manejar esto en Compose, necesitamos "registrar" una oficina de recepci√≥n de respuestas antes de pedir nada. Eso es lo que hace `rememberLauncherForActivityResult`.

**Imagina que es como el "Busca" (Beeper) de los 100 Montaditos:**

- T√∫ llegas (se inicia la pantalla) y pides lo que quieres: Una de patatas 4 salsas, un 90...
- Pagas y el camarero te da un "Busca" (**creas el Launcher**).
- T√∫ te sientas a esperar.
- Cuando la mesa est√° lista, el aparato vibra y t√∫ reaccionas a por tus patatas (**se ejecuta el c√≥digo dentro de las llaves `{ }`**).

Vamos a hacer un forensics a este bloque de c√≥digo para entenderlo de verdad:

```kotlin
val permissionLauncher = rememberLauncherForActivityResult(
    contract = ActivityResultContracts.RequestMultiplePermissions()
) { permissions -> 
    // ... c√≥digo de respuesta ...
}
```

**1. `rememberLauncherForActivityResult`**:

- **¬øQu√© es?**: Es una funci√≥n de Compose que "registra" nuestra petici√≥n al sistema operativo.
- **¬øPor qu√© `remember`?**: En Compose, la pantalla se redibuja (recompone) constantemente. Si no us√°ramos `remember`, cada vez que la pantalla parpadeara, perder√≠amos la conexi√≥n con nuestra petici√≥n de permisos. Esto mantiene al "intermediario" vivo.

**2. `contract = ActivityResultContracts.RequestMultiplePermissions()`**:

- **El Contrato**: Aqu√≠ le decimos a Android **qu√© tipo de tarea** vamos a hacer. No es lo mismo pedir "Hacer una foto" (`TakePicture`) que "Pedir Permisos" (`RequestMultiplePermissions`).
- Al definir este contrato, Android ya sabe que cuando vuelva con la respuesta, debe traernos un mapa con los resultados de los permisos.

**3. `{ permissions -> ... }` (La Callback o "El Buz√≥n")**:

- Todo lo que escribas entre estas llaves **NO se ejecuta ahora**.
- Es el c√≥digo que se ejecutar√° **EN EL FUTURO**, justo en el momento en que el usuario pulse "Permitir" o "Denegar" en la ventana emergente.
- **La variable `permissions`**: Es el cartero. Es un `Map` (un diccionario) que contiene los pares de:
  - *Clave:* El nombre del permiso (ej. `ACCESS_FINE_LOCATION`).
  - *Valor:* `true` (concedido) o `false` (denegado).

**¬øC√≥mo se usa despu√©s? (El bot√≥n):**

Una cosa es **contratar al mensajero** (lo que acabamos de hacer arriba) y otra es **mandarlo a trabajar**.

Ahora ve al bot√≥n **"Calcula distancia..."** y haz que lance la petici√≥n:

Por eso, el c√≥digo anterior se pone al principio de la funci√≥n, pero el "disparo" se hace en el bot√≥n:

```kotlin
// En el onClick del bot√≥n:
permissionLauncher.launch( // <--- ¬°A trabajar!
    arrayOf(
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION
    )
)
```

Al llamar a `.launch()`, es cuando realmente aparece la ventana emergente en la pantalla del usuario.

-----

### 1.3.8. La L√≥gica Matem√°tica (Google Play Services)

Por √∫ltimo, vamos a implementar la funci√≥n `calculateAndShowDistance` al final del archivo. Aqu√≠ es donde ocurre la magia de `LocationServices`.

> **Atenci√≥n:** Necesitar√°s importar muchas clases. Si sale en rojo, pulsa `Alt+Enter` e importa.
> `Priority` viene de `com.google.android.gms.location`. Ojo que muchas importaciones son ambiguas y toca decir, Locale por ejemplo viene de `java.util`.

```kotlin
private fun calculateAndShowDistance(context: Context, instituteLat: String, instituteLon: String) {
    // 1. Obtenemos el cliente de ubicaci√≥n de Google
    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)

    // 2. IMPORTANTE: Aunque el usuario haya dicho "S√≠" antes, 
    // Android exige por seguridad volver a verificar el permiso antes de llamar a la API.
    if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {

        // 3. Pedimos la ubicaci√≥n ACTUAL
        // PRIORITY_HIGH_ACCURACY: Usa GPS (gasta m√°s bater√≠a, pero es exacto)
        fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, CancellationTokenSource().token)
            .addOnSuccessListener { userLocation: Location? ->
                if (userLocation != null) {
                    // A. Creamos la ubicaci√≥n del Instituto
                    val instituteLocation = Location("provider").apply {
                        latitude = instituteLat.toDouble()
                        longitude = instituteLon.toDouble()
                    }

                    // B. Calculamos la distancia (magia matem√°tica de Android)
                    val distanceInMeters = userLocation.distanceTo(instituteLocation)
                    val distanceInKm = distanceInMeters / 1000f

                    // C. Mostramos resultado
                    val msg = String.format(Locale.getDefault(), "Est√°s a %.2f km del instituto", distanceInKm)
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show()
                } else {
                    Toast.makeText(context, "No se pudo obtener la ubicaci√≥n (GPS desactivado?)", Toast.LENGTH_SHORT).show()
                }
            }
            .addOnFailureListener {
                Toast.makeText(context, "Error al obtener ubicaci√≥n", Toast.LENGTH_SHORT).show()
            }
    }
}
```

-----

**üîé Forense de C√≥digo: `calculateAndShowDistance`**

Esta funci√≥n es la encargada de hacer el trabajo sucio. Vamos a diseccionarla pieza a pieza porque aqu√≠ ocurren varias cosas "invisibles" que es vital entender. Muchas son espec√≠ficas de la API de Google Play Services, pero bueno trabajar con temas de ubicaci√≥n es relativamente com√∫n, por lo que las explicaremos. No te asustes, es normal no acordarse de esto hasta que te toque hacerlo en un proyecto real, que sepas que puedes volver aqu√≠ a repasarlo o buscar en la documentaci√≥n oficial.

#### El Cliente Fusionado (`FusedLocationProviderClient`)

```kotlin
val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
```

- **¬øQu√© es esto?** Antiguamente, en Android ten√≠as que elegir: "¬øUso el GPS (preciso pero lento) o el Wi-Fi (r√°pido pero impreciso)?".
- **La soluci√≥n de Google:** El `FusedLocationProvider` es un "cerebro" inteligente. √âl decide autom√°ticamente qu√© sensores combinar (fusionar) para darte la mejor ubicaci√≥n posible ahorrando bater√≠a. Es la puerta de entrada a los servicios de ubicaci√≥n.

#### El Doble Check de Seguridad (`checkSelfPermission`)

```kotlin
if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) { ... }
```

- **La Pregunta:** *"¬øPero no hab√≠amos pedido ya el permiso en el bot√≥n anterior?"*
- **La Respuesta:** S√≠, pero **Android no se f√≠a**. El usuario podr√≠a haber minimizado la app, ido a Ajustes y quitado el permiso hace 5 segundos.
- **La Regla:** Siempre, justo antes de ejecutar una l√≠nea de c√≥digo que requiera permisos (`getCurrentLocation`), debes verificar si *siguen* concedidos. Si no pones este `if`, el compilador te marcar√° un error rojo (Lint Error) diciendo que es inseguro.

#### La Petici√≥n As√≠ncrona (`getCurrentLocation`)

```kotlin
fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, CancellationTokenSource().token)
```

Aqu√≠ pedimos la ubicaci√≥n. F√≠jate en dos detalles:

- **`PRIORITY_HIGH_ACCURACY`**: Le decimos: "Enciende el GPS, quiero precisi√≥n m√°xima".
- **`CancellationToken`**: Es un "token de cancelaci√≥n". Es obligatorio pasarlo. Sirve por si quisieras cancelar la petici√≥n a medias (por ejemplo, si el usuario cierra la app antes de que el sat√©lite responda), aunque aqu√≠ no lo usaremos activamente.

#### El Concepto de "Listener" (El que espera)

```kotlin
.addOnSuccessListener { userLocation: Location? -> ... }
```

Obtener la ubicaci√≥n **tarda tiempo** (milisegundos o segundos). No podemos detener la app esperando al sat√©lite (la pantalla se congelar√≠a).

- Por eso usamos un **Listener**: un bloque de c√≥digo que se ejecuta **cuando el dato est√° listo**.
- Le decimos a Android: *"Sigue con tu vida, y cuando tengas el dato, av√≠same ejecutando este bloque de c√≥digo"*.
  - **El potencial `null`**: F√≠jate que `userLocation` puede ser nulo (`?`). ¬øPor qu√©?
    - El GPS est√° apagado.
    - Est√°s en un t√∫nel.
    - El m√≥vil acaba de reiniciarse y a√∫n no sabe d√≥nde est√°.
    - Por eso es **obligatorio** el `if (userLocation != null)`.

#### Matem√°ticas Geod√©sicas (`distanceTo`)

Tranquilo, casi todo viene ya enlatado en funciones que hacen las matem√°ticas duras por nosotros. Ten en cuenta que el tema de la geometr√≠a de la Tierra es complejo (esf√©rica, elipsoide, etc.), a pesar de lo que algunos digan **NO es plana**, pero Android nos lo simplifica.

```kotlin
val instituteLocation = Location("manual").apply {
    latitude = instituteLat.toDouble()
    longitude = instituteLon.toDouble()
}
val distanceInMeters = userLocation.distanceTo(instituteLocation)
```

- **Crear un punto destino:** Para calcular la distancia, necesitamos dos puntos. El `userLocation` (que nos acaba de llegar) y el del instituto. Creamos un objeto `Location` manual meti√©ndole las coordenadas que ten√≠amos guardadas arriba.
- **`distanceTo`:** Esta funci√≥n es magia pura. Calcula la distancia en l√≠nea recta sobre la curvatura de la Tierra (usando f√≥rmulas complejas como la de Haversine, que calcula la distancia *ortodr√≥mica*, la m√°s corta entre dos puntos en una esfera y que NO es una l√≠nea recta en un plano) y nos devuelve el resultado en **metros**.

#### El Toque Final (Formato)

```kotlin
String.format(Locale.getDefault(), "Est√°s a %.2f km", distanceInKm)
```

- Convertimos metros a kil√≥metros dividiendo por 1000.
- Usamos `String.format` para que solo muestre 2 decimales (`%.2f`). Adem√°s, al usar `Locale.getDefault()`, si el m√≥vil est√° en Espa√±a usar√° una coma (`15,40 km`) y si est√° en EEUU usar√° un punto (`15.40 km`). ¬°Detalles de profesional\!

**Resumen Visual del Flujo:**

Para que que vosotros (y yo) podamos visualizarlo, el flujo de esta funci√≥n es:

1. **START** -> ¬øTengo herramienta `fused`?
2. **CHECK** -> ¬øSigo teniendo permiso?
3. **REQUEST** -> "Sat√©lite, dime d√≥nde estoy (Alta Precisi√≥n)".
4. **WAIT** -> ... (La app sigue funcionando) ...
5. **CALLBACK** ->  Aqu√≠ tienes la ubicaci√≥n (o null).
6. **CALCULATE** -> Distancia entre (Yo) y (Instituto).
7. **SHOW** -> Toast con el resultado (o el error).

-----

### 1.4. Conclusi√≥n

¬°Felicidades! Has creado una app que interact√∫a completamente con el ecosistema Android. Has aprendido a:

1. Comunicarte con otras apps (Maps, Tel√©fono, Navegador) usando **URIs**.
2. Gestionar errores cuando una app no existe (WhatsApp).
3. Implementar el flujo completo de **Permisos en Tiempo de Ejecuci√≥n** (solicitar, esperar respuesta, actuar).
4. Usar los **Google Play Services** para geolocalizaci√≥n.

### Recursos adicionales sobre Intents

- [https://developer.android.com/training/basics/intents](https://developer.android.com/training/basics/intents)
- [https://developer.android.com/courses/pathways/android-basics-compose-unit-5-pathway-1](https://developer.android.com/courses/pathways/android-basics-compose-unit-5-pathway-1)

## 2. Consumo de APIs REST con Retrofit y Coroutines

Vamos a seguir el codelab oficial de Google para aprender a consumir APIs REST usando Retrofit junto con Coroutines en un entorno de Jetpack Compose.

Realizaremos la **Unit 5: Connect to internet** [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course)
Aqu√≠ se explica paso a paso c√≥mo configurar Retrofit, definir las interfaces de la API, manejar las respuestas y errores, y mostrar los datos en la UI usando Compose.

Para la parte de c√≥mo implementar un login, nos podemos apoyar en el siguiente codelab: [https://developers.google.com/learn/pathways/firebase-android-jetpack](https://developers.google.com/learn/pathways/firebase-android-jetpack) . En este caso, es suficiente con mirar seguir los 3 primeros m√≥dulos donde se cubren los conceptos b√°sicos de autenticaci√≥n con Firebase. Tanto el tema de **Flows** en el contexto de Firebase, como el resto de cuestiones los dejaremos de momento fuera, ya que son temas avanzado que exceden el alcance de este curso b√°sico.

Ahora vamos a hacer una pr√°ctica "libre" para asentar los conocimientos adquiridos. Se trata de la t√≠pica app de Pok√©dex que consume la API p√∫blica de PokeApi [https://pokeapi.co/](https://pokeapi.co/). Al proyecto lo hemos llamado **PcDeAlguien** como gui√±o al famoso inform√°tico de Kanto, **Bill**, creador del sistema de almacenamiento de Pok√©mon.

El repositorio lo ten√©is en [https://github.com/scontreraslopez/pc-de-alguien](https://github.com/scontreraslopez/pc-de-alguien)

### 1. El Endpoint

```http
GET https://pokeapi.co/api/v2/generation/{id}/
```

Donde `{id}` es el n√∫mero de la generaci√≥n (1 para Kanto, 2 para Johto, etc.).

**Ejemplo para la Generaci√≥n 1:**
`https://pokeapi.co/api/v2/generation/1/`

-----

### 2. ¬øQu√© te devuelve? (El JSON)

Aqu√≠ viene el "truco" para mantenerlo sencillo. Este endpoint devuelve un objeto grande, pero a ti solo te interesa la lista llamada `pokemon_species`.

El JSON se ve as√≠ (simplificado):

```json
{
  "id": 1,
  "name": "generation-i",
  "pokemon_species": [
    {
      "name": "bulbasaur",
      "url": "https://pokeapi.co/api/v2/pokemon-species/1/"
    },
    {
      "name": "charmander",
      "url": "https://pokeapi.co/api/v2/pokemon-species/4/"
    }
    // ... resto de la lista
  ]
}
```

-----

### 3. La Estrategia para las Im√°genes (Importante)

Si te fijas, el JSON de arriba **no trae la imagen**, solo el `name` y una `url` de detalles.

Para **no complicarte** haciendo una segunda llamada a la API por cada Pok√©mon (lo cual ser√≠a lento y complejo para una pr√°ctica sencilla), usaremos un truco est√°ndar con **Coil**:

1. Obtienes la lista de la generaci√≥n.
2. Extraes el **ID** del Pok√©mon de la `url` (ej: de `.../pokemon-species/1/` sacas el `1`).
3. Construyes la URL de la imagen manualmente en tu Adapter usando el patr√≥n oficial de los sprites de PokeApi:

> **URL de imagen directa:**
> `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/{id}.png`

De esta forma, Retrofit solo hace **una** llamada (la lista) y Coil se encarga de cargar las im√°genes bajo demanda mientras haces scroll.

-----

### ¬øC√≥mo seguimos?

> [!NOTE]
> Las dependencias ya las tienes importadas, pero no te acuerdes de a√±adir el permiso de Internet en el Manifest.

`<uses-permission android:name="android.permission.INTERNET" />`.

-----

### Resumen de la Tarea para el alumno

1. Rellenar las **Data Classes** (Modelo).
2. Implementar la interfaz **ApiService** y el objeto **RetrofitClient**. Si lo prefires, por seguir los pasos del codelab de **MarsPhoto**, puedes utilizar el patr√≥n de repositorio. La inyecci√≥n manual de dependencias (`AppContainer.kt`) es totalmente opcional.
3. Completar la funci√≥n `fetchPokemonByGeneration` en el **ViewModel**.
4. Implementar la l√≥gica de extracci√≥n de ID y URL de imagen en el composable `PokemonItem`.

Esta estructura que te doy es totalmente flexible. Si quieres organizar el c√≥digo de otra forma, usar otro patr√≥n arquitect√≥nico, etc. eres libre de hacerlo siempre que cumplas los requisitos funcionales.

> [!IMPORTANT]
> Respecto a las entregas: esta unidad no habr√° entrega parcial, pero, al final de la siguiente unidad os voy a pedir lo siguiente, por favor ir avanzando no se os haga bola.

- Severo Ochoa Intents al que a√±adir√©is un Intent a vuestra elecci√≥n, por ejemplo a√±adir cita al calendario.
- PC de Alguien que muestra el grid de pok√©mons por generaci√≥n, nombre e imagen no hace falta nada m√°s.
- La tarea del Proyecto Intermodular (inicio) o tarea equivalente si no est√°is cursando el proyecto intermodular.

**Evidentemente, la tarea de la siguiente unidad calificar√° doble.**

En cualquier caso, te dejo una receta de cocina para el uso de **Retrofit** (la parte de **Coil** es trivial, basta con hacer empleo del composable `AsyncImage`).

### Receta de Cocina: Retrofit en Jetpack Compose con Coroutines

1. üìã **Comprar los Ingredientes. A√±adir dependencias en Gradle:**

Vamos a usar Kotlinx Serialization (es el est√°ndar moderno sobre GSON) y Coil para im√°genes.

En la parte de `plugins` de `build.gradle.kts (Module: app)` a√±ade:

```kotlin
    kotlin("plugin.serialization") version "2.2.21"
```

En la parte de `dependencies` a√±ade:

```kotlin
    // Runtime de Kotlin Serialization (JSON)
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.9.0")

    // Retrofit core
    implementation("com.squareup.retrofit2:retrofit:3.0.0")

    // Converter oficial de Retrofit para kotlinx.serialization (NO Jake Wharton del Codelab que esta deprecated)
    implementation("com.squareup.retrofit2:converter-kotlinx-serialization:3.0.0")

    // 2. Im√°genes (Coil)
    implementation("io.coil-kt:coil-compose:2.7.0")

    // 3. ViewModel & Lifecycle
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.10.0")
```

En el archivo `AndroidManifest.xml` a√±adimos el permiso de Internet:

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

2. ü•£ **Paso 1: La "Mise en Place" (Capa de Datos - Modelos)**

Aqu√≠ vamos a definir los datos que vienen de la red. Como hablamos de datos de la red, mi recomendaci√≥n es usar el paquete `com.tuapp.network`. A esta clase la podemos llamar por ejemplo `PokeApiDtos.kt`. Aqu√≠ estamos usando kotlinx.serialization, que es el est√°ndar moderno para serializar y deserializar JSON en Kotlin, *mejor* que GSON. Esto se llama DTOs (Data Transfer Objects), por que son las clases que representan los datos que vienen de la red. En este sentido los atributos que estas clases tienen deben coincidir exactamente con los nombres de los campos del JSON que nos devuelve la API, o en su defecto ser un subconjunto de los mismos. Como los nombres de los campos pueden ser feos para Kotlin (por ejemplo con guiones), usamos la anotaci√≥n `@SerialName` para mapearlos correctamente.

```kotlin
/* Con SerialName mapeamos nombre */
@Serializable
data class PokemonGenerationResponse(
    @SerialName(value="pokemon_species") val pokemons: List<PokemonDto>
)

/* Es importante que se ajuste a lo que manda el JSON, de ah√≠ DTO o fallar√° */

@Serializable
data class PokemonDto(
    @SerialName("name") val name: String,
    @SerialName("url") val url: String
)
```

3. **üç≥ Paso 2: La Salsa (Capa de Red - API)**

Si ya tenemos los objetos que nos traemos de la API, ahora falta decirle de d√≥nde los traemos. Aqu√≠ definimos la interfaz de Retrofit. Como hablamos de datos de la red, mi recomendaci√≥n es de nuevo usar el paquete `com.tuapp.network`. A esta clase la podemos llamar por ejemplo `PokeApiDtos.kt`.

```kotlin
interface PokemonApiService {
// 1. Obtener la lista de generaciones (usa tu GenerationsResponse)
@GET("generation")
suspend fun getGenerations(): GenerationsResponse

...
```

4. ü•ò **Paso 3: El Cocinado (Capa de Datos - Repositorio)**

Aqu√≠ se nos abre una disyuntiva. Podemos hacer que el ViewModel hable directamente (con el `Singleton` de *RetrofitClient*) con la API o podemos crear una capa intermedia llamada Repositorio que abstraiga la fuente de datos. La opci√≥n del repositorio es la m√°s profesional y escalable, de hecho es la que se explica en el codelab oficial de Google, pero tambi√©n es verdad que para pr√°cticas sencillas se siente como un **overkill**. En esta pr√°ctica sientete libre de elegir la opci√≥n que m√°s te guste, en lo profesional s√≠ que te recomendaria usar el patr√≥n de repositorio si la aplicaci√≥n tiene visos de crecer en el futuro.

El tema de repositorio es especialmente √∫til si en el futuro queremos cambiar la fuente de datos (por ejemplo, usar una base de datos local o cach√©). Aqu√≠ vamos a crear un repositorio simple que hable con la API, por explicarlo alineado con el codelab. Podemos crear una clase llamada `PokemonRepository.kt` en el paquete `com.tuapp.data`.

El repositorio tiene dos partes:

- La interfaz (contrato) que define qu√© operaciones puede hacer el repositorio, y que implementar√≠an todas las implementaciones concretas del mismo (por ejemplo, una que hable con la red, otra que hable con una base de datos local, etc).
- Las implementaciones concreta que habla con la API (o la base de datos, etc). Aqu√≠ inyectamos el servicio de Retrofit.

Esto es un patr√≥n de dise√±o muy com√∫n en desarrollo de software llamado **Repository Pattern**.

```kotlin
// Interfaz para facilitar testing (Best Practice)
interface PokemonRepository{
    suspend fun getGenerationPokemons(generation: Int): List<PokemonDto>
    suspend fun getGenerations(): List<GenerationDto>
}

// Implementaci√≥n concreta. Inyectamos el servicio, no lo creamos aqu√≠
class NetworkPokemonRepository(
    private val apiService: PokeApiService
): PokemonRepository {
    override suspend fun getGenerationPokemons(generation: Int): List<PokemonDto> {
        return apiService.getGenerationPokemons(generation).pokemons
    }


    override suspend fun getGenerations(): List<GenerationDto> {
        return apiService.getGenerations().results
    }
}
```

5. üì¶ **Paso 4: El Contenedor (Manual Dependency Injection)**

Como hemos comentado alternativamente podr√≠as implementar el ViewModel para que hable directamente con el servicio de Retrofit (v√≠a un singleton `RetrofitClient`), pero si has optado por el patr√≥n de repositorio, necesitamos una forma de inyectar el repositorio en el ViewModel. Para ello, vamos a crear un contenedor de dependencias manual muy simple. En proyectos reales se usan librer√≠as como **Hilt** o **Koin**, pero para pr√°cticas sencillas esto es suficiente. Estas cosas las comento para que os suenen, por si en el futuro ten√©is que buscar que sep√°is por d√≥nde.

Para la inyecci√≥n manual de dependencias, creamos un objeto llamado `AppContainer.kt` en el paquete `com.tuapp.di` (dependency injection) o `com.tuapp.data`.

De nuevo esto trae dos partes:

- La interfaz que define qu√© dependencias expone el contenedor (en este caso solo el repositorio).
- La implementaci√≥n concreta que crea las dependencias (el servicio de Retrofit y el repositorio). Aqu√≠ aprovechamos para indicar tambi√©n la configuraci√≥n de Retrofit (base URL, convertidor, etc). Fijate que usamos `by lazy` para inicializar las dependencias solo cuando se usan por primera vez (Best Practice). **Especial atenci√≥n** a la l√≠nea de ignoreUnknownKeys en el Json, que evita fallos si la API devuelve campos extra que no tenemos en nuestros DTOs.

```kotlin
interface AppContainer {
    val pokemonRepository: PokemonRepository
}

class DefaultAppContainer: AppContainer {
    private val baseUrl = "https://pokeapi.co/api/v2/"

    //Empezamos a inicializar primero Retrofit, siempre lazy.
    private val retrofit: Retrofit by lazy {
        Retrofit.Builder()
            .addConverterFactory(Json {
                ignoreUnknownKeys = true
            }.asConverterFactory("application/json".toMediaType()))
            .baseUrl(baseUrl)
            .build()
    }

    private val retrofitService: PokeApiService by lazy {
        retrofit.create(PokeApiService::class.java)
    }

    override val pokemonRepository: PokemonRepository by lazy {
        NetworkPokemonRepository(retrofitService)

    }
}
```

Este paso es el m√°s pesado, por eso todav√≠a quedan cosas, ahora tenemos que instanciar esto en una clase que extienda de `Application`, para que est√© disponible en toda la app. Creamos una clase llamada `PokemonApplication.kt` en el paquete ra√≠z `com.tuapp`.

```kotlin
class PokemonApplication: Application() {

    lateinit var container: AppContainer
    override fun onCreate() {
        super.onCreate()
        container = DefaultAppContainer()
    }
}
```

Probablemente sea incluso buena idea juntarla con MainActivity o con PokemonApp.kt, pero por replicar el codelab he preferido dejarlo separado.

Por √∫ltimo, que no se te olvide registrar esta clase en el Manifest:

```xml
<application
    android:name=".PokemonApplication"
    ... >
```

Esas tres cosas son las que hacen que la inyecci√≥n manual de dependencias funcione.

6. **üë®‚Äçüç≥ Paso 5: El Chef (Capa de Presentaci√≥n - ViewModel)**

El vista modelo ya lo conoc√©is de sobra a estas alturas pero, aprovechando que el codelab lo introduc√≠a, vamos a usar el tema de las **Sealed Interfaces**. Esto es una Best Practice muy recomendable para evitar estados inconsistentes en la UI.

En el t√≠pico archivo `PokemonUiState.kt` en el paquete `com.tuapp.ui` definimos el estado de la UI. Aqu√≠ es donde usamos una **clase de datos** para los datos persistentes (como la generaci√≥n seleccionada) y una **sealed interface** para los estados exclusivos de la petici√≥n (Cargando, Error, Datos).

```kotlin
 UiState: Una sola clase que lo tiene todo
data class PokemonUiState(
    // Datos de la pantalla (persisten siempre)
    val selectedGeneration: Int = 1,
    val generations: Int = 1, // Podr√≠amos poner 9 pero la gracia es que lo recupere de la API.
    // Estado de la petici√≥n (aqu√≠ usamos la l√≥gica excluyente para la lista)
    val requestStatus: RequestStatus = RequestStatus.Idle  // Esto es lo mismo que hace el codelab con MarsPhoto
)

// Estado exclusivo solo para la carga de datos
sealed interface RequestStatus {
    ...
    data class Success(val pokemons: List<PokemonDto>) : RequestStatus
    object Error : RequestStatus
}
```

F√≠jate como el tema de las listas de pok√©mons lo hemos metido dentro del estado exclusivo `RequestStatus`. De esta forma, si el estado es `Loading` o `Error`, no hay lista de pok√©mons, y si es `Success`, la lista siempre est√° presente. Esto evita estados inconsistentes en la UI (por ejemplo, tener una lista visible pero el estado en `Loading`).

Ten en cuenta que no te doy las clases enteras pueden que falten cosas pero para que la idea se entienda.

Ahora vamos al viewmodel `PokemonViewModel.kt` en el paquete `com.tuapp.ui`.

Una posible implementaci√≥n (parcial) ser√≠a:

```kotlin
class PokemonViewModel(
    private val pokemonRepository: PokemonRepository
) : ViewModel() {

    // Estado para la lista de pokemons. Arranca cargando y el resto lo de siempre
    private val _uiState = MutableStateFlow(PokemonUiState(
        requestStatus = RequestStatus.Loading //Arranca cargando
    ))
    val uiState: StateFlow<PokemonUiState> = _uiState.asStateFlow()

    //Al init lo que hay que hacer es pescar las generations y con eso darle los valores al dropdown
    init {
        getGenerations()
    }

    private fun getGenerations() {
        viewModelScope.launch {
            try {
                //Cogemos la lista de generations del repository
                val generationList = pokemonRepository.getGenerations()
                _uiState.update { currentState ->
                    val generationsCount = generationList.count()
                    currentState.copy(
                        generations = generationsCount,
                        requestStatus = RequestStatus.Idle
                    )
                }
            } catch (e: Exception) {
                _uiState.update { currentState ->
                    currentState.copy(requestStatus = RequestStatus.Error)
                }
            }
        }
    }

    fun selectGeneration(generation: String) {
        _uiState.update { currentState ->
            currentState.copy(selectedGeneration = generation.toIntOrNull() ?: 1)
        }
    }

    // Funci√≥n para llamar a la API
    fun fetchPokemonByGeneration(generationId: Int) {
        viewModelScope.launch {
          ...
    }

    companion object {
        val Factory: ViewModelProvider.Factory = viewModelFactory {
            initializer {
                val application = (this[APPLICATION_KEY] as PokemonApplication)
                val pokemonRepository = application.container.pokemonRepository
                PokemonViewModel(pokemonRepository = pokemonRepository)
            }
        }
    }
}
```

En este punto quiero llamar la atenci√≥n de un par de cosas de esta implementaci√≥n (parcial):

- La l√≠nea por la que se le inyecta el repositorio al ViewModel:

```kotlin
class PokemonViewModel(
    private val pokemonRepository: PokemonRepository
) : ViewModel()
```

Si no hemos realizados los pasos anteriores de inyecci√≥n manual de dependencias, esto crashear√° en tiempo de ejecuci√≥n, y puede ser complicado de depurar si no se entiende bien el flujo.

- La corutina dentro de `viewModelScope.launch { ... }` para hacer la llamada a la API de forma as√≠ncrona sin bloquear el hilo principal. Dentro de una corutina podemos llamar a funciones `suspend` como las del repositorio. Lo maravilloso de las corutinas es que el c√≥digo se lee de forma secuencial, pero bajo el cap√≥ no bloquea el hilo principal, as√≠ es muy sencillo poner el estado cargando y luego actualizar la UI cuando llegan los datos, sin meternos en cosas complicadas de `threads` o `callbacks`.

- El bloque del `companion object` con el Factory para que el ViewModel pueda ser instanciado por la Activity o Composable con la inyecci√≥n de dependencias correcta. Esto es otro peaje por el tema de la inyecci√≥n de dependencias manual, pero es necesario para que funcione, si no lo de siempre, crashear√° en tiempo de ejecuci√≥n.

Qu√© de patrones de dise√±o, ¬øverdad?: Hemos tocado, MVVM (primo hermano del Controller), Singleton, Factory, Repository... Si rascamos hay m√°s, hay Builders camuflados te preocupes si no los entiendes todos a la perfecci√≥n ahora mismo, lo importante es que veas el flujo general y poco a poco ir√°s entendiendo mejor cada pieza. Lo dicho, incluso a los que est√°n m√°s bregados desarrollo, les cuesta entender todo esto, Android es as√≠, te abruma por todos los frentes: Dise√±o, Arquitectura, APIs, Librer√≠as, Patrones de dise√±o... Pero poco a poco se va asimilando.

Por eso, si prefer√≠s pod√©is simplificar, pero para que conozc√°is las buenas pr√°cticas, os lo he puesto as√≠.

Por √∫ltimo, toca enganchar esto en **PokemonApp.kt** para que el Composable ra√≠z pueda obtener el ViewModel con la inyecci√≥n de dependencias correcta.

```kotlin
@Composable
fun PokemonApp( ) {
    val viewModel: PokemonViewModel =
        viewModel(factory = PokemonViewModel.Factory)
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
        PokemonScreen(
            uiState = uiState,
            onFetchClick = {viewModel.fetchPokemonByGeneration(uiState.selectedGeneration)},
            onGenerationSelection = {viewModel.selectGeneration(it)},
            modifier = Modifier.padding(innerPadding))

    }
}
```

Este punto tambi√©n he aprovechado para resolverlo de otra manera, en lugar de pasar el ViewModel a las diferentes pantallas, paso solo el `uiState` y los callbacks necesarios. Esto es una cuesti√≥n de estilo, pero me gusta m√°s porque las pantallas son m√°s "dumb" y no tienen l√≥gica, solo muestran datos y lanzan eventos. De nuevo, si prefer√≠s pasar el ViewModel entero, en el nivel que nos movemos, pod√©is hacerlo sin problema.

Otro comentario que quiero hacer en es de las diferentes estrat√©gias que podemos hacer con el ViewModel si tenemos varias pantallas. En general la mejor (en escalabilidad) soluci√≥n es tener un ViewModel por pantalla y un repositorio compartido entre ellos. Ahora una soluci√≥n compromiso es tener un ViewModel compartido entre varias pantallas (en particular si estas est√°n muy relacionadas, por ejemplo una pantalla de lista y una de detalles) y en cualquier caso generar ya UiStates espec√≠ficos para cada pantalla. Pero bueno, esto ya es cuesti√≥n de dise√±o de la app y no hay una √∫nica soluci√≥n correcta, depende mucho del caso de uso.

### üçΩÔ∏è Paso 6: El Emplatado (UI Layer - Compose)

Finalmente, pintamos la UI usando `LazyVerticalGrid` y `AsyncImage` (Coil).

En la clase `PokemonScreen.kt` en el paquete `com.tuapp.ui` definimos el Composable principal de la pantalla.

```kotlin
@Composable
fun PokemonScreen(
    uiState: PokemonUiState,
    onFetchClick: (Int) -> Unit,
    onGenerationSelection: (String) -> Unit,
    modifier: Modifier = Modifier

) {
    // Observamos el estado del ViewModel
    //val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    // Fijate que esto no puedo hacerlo por que no siempre habr√° lista val pokemonList = uiState.requestStatus.pokemons
    val generationsCount = uiState.generations
    val selectedGen = uiState.selectedGeneration

    // Variables para el Dropdown (UI ya resuelta)
    val generations = (1..generationsCount).toList() // Generations


    ...

// --- LISTA DE RESULTADOS --- -> Funci√≥n del estado
        when (val status = uiState.requestStatus) {
            is RequestStatus.Loading -> CircularProgressIndicator()
            is RequestStatus.Error -> Text("Error")
            is RequestStatus.Success -> {
                // Aqu√≠ pintamos la lista
                LazyVerticalGrid(
                    modifier = Modifier.weight(1f),
                    columns = GridCells.Fixed(2), // 2 columnas
                    verticalArrangement = Arrangement.spacedBy(8.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(status.pokemons) { pokemon ->
                        PokemonItem(pokemon)
                    }
                }
            }

            is RequestStatus.Idle -> Text("Selecciona una generaci√≥n y pulsa buscar")
        }
```

Lo que es la tarjeta de cada Pok√©mon lo tenemos en el Composable `PokemonItem`, que seguramente hubiera sido mejor poner en un archivo aparte `PokemonItem.kt` en el mismo paquete `com.tuapp.ui.components`.

```kotlin
@Composable
fun PokemonItem(pokemon: PokemonDto) {
    Card(
        elevation = CardDefaults.cardElevation(4.dp),
        colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5))
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.padding(8.dp).fillMaxWidth()
        ) {
            // TODO 5: Construir la URL de la imagen
            // üü¢ DONE:
            // 1. Obtener el ID desde la URL del pokemon (pokemon.url)
            // 2. Usar: https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/{id}.png

            // Como la URL del pokemon tiene esta pinta: "https://pokeapi.co/api/v2/pokemon-species/4/ lo que me insteresa es extraer el 4
            // Si leemos el m√©thod split veremos que si usamos / como delimitador devolver√° el siguiente array: [https:, , pokeapi.co, api, v2, pokemon-species, 4, ], pues nos interesa coger el pen√∫ltimo y ya est√°

            val splitUrl = pokemon.url.split("/")
            val pokemonId = splitUrl[splitUrl.lastIndex - 1] //Hay mil maneras similares de lograr lo mismo
            val imageUrl = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/$pokemonId.png"

            // Esta es la magia de Coil
            AsyncImage(
                model = imageUrl,
                contentDescription = pokemon.name,
                modifier = Modifier.size(100.dp)
            )

            Text(
                text = pokemon.name.uppercase(),
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}
