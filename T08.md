# T08-Navegaci√≥n en Android

## √çndice

## Introducci√≥n

La navegaci√≥n se refiere a las interacciones y patrones que permiten a los usuarios moverse dentro de una aplicaci√≥n Android. Una navegaci√≥n efectiva es crucial para proporcionar una experiencia de usuario fluida y coherente.

El siguiente art√≠culo cubre los principios de navegaci√≥n en Android: [Principios de Navegaci√≥n en Android](https://developer.android.com/guide/navigation/principles)  

## Componente de Navegaci√≥n (Navigation Component)

El componente de Navegaci√≥n de Android Jetpack simplifica la implementaci√≥n de la navegaci√≥n entre las pantallas de una aplicaci√≥n. Sus principales caracter√≠sticas son:

- Maneja correctamente la pila de pantallas (*back stack*).
- Gestiona transiciones de fragmentos de forma autom√°tica.
- Controla diversos casos de uso, desde clics simples en botones hasta patrones m√°s complejos como las barras de la aplicaci√≥n y el panel lateral de navegaci√≥n.

### Recursos Adicionales

- **Documentaci√≥n oficial**: [Gu√≠a del componente de Navegaci√≥n](https://developer.android.com/guide/navigation?hl=es-419)
- **V√≠deo explicativo**: [Navegaci√≥n en Android con Navigation Component](https://www.youtube.com/watch?v=1OxiEaEWEe4)

### Conceptos Clave

| Concepto | Prop√≥sito | Tipo |
| :--- | :--- | :--- |
| **Host** | Un elemento de la IU que contiene el destino de navegaci√≥n actual. Cuando un usuario navega por una app, esta intercambia destinos dentro y fuera del host de navegaci√≥n. | `NavHost` |
| **Gr√°fico** | Es una estructura de datos que define todos los destinos de navegaci√≥n dentro de la app y c√≥mo se conectan entre s√≠. | `NavGraph` |
| **Controlador** | Es el coordinador central para administrar la navegaci√≥n entre destinos. Ofrece m√©todos para navegar, controlar v√≠nculos directos y administrar la pila de actividades. | `NavController` |
| **Destino** | Nodo en el gr√°fico de navegaci√≥n. Cuando el usuario navega a este nodo, el host muestra su contenido. Se crea al construir el gr√°fico de navegaci√≥n. | `NavDestination` |
| **Ruta** | Identifica de manera inequ√≠voca un destino y los datos que requiere. Las rutas te llevan a los destinos. | Cualquier tipo de datos serializables (p. ej., `String`). |


¬°Ojo tanto aqu√≠ como en el MVVM el codelab trae algunas grandle dependencies ya de serie, pero si arrancas un proyecto nuevo, acu√©rdate de a√±adirlas!



Estas se a√±aden en el archivo `build.gradle.kts` a nivel de m√≥dulo (el que pone Module: app). Una vez dentro busca la secci√≥n de `dependencies` y a√±ade las l√≠neas que falten.

M√°s info de lo que hace falta aqu√≠ para navigation: https://developer.android.com/jetpack/androidx/releases/navigation

Y para el tema del ViewModel aqu√≠: https://developer.android.com/jetpack/androidx/releases/lifecycle

¬°No hay que importarlas todas, solo las que necesitemos! Si importamos a troche y moche el proyecto crecer√° innecesariamente.

https://developer.android.com/courses/pathways/android-basics-compose-unit-4-pathway-2


Parts of the Navigation Component
The Navigation component has three main parts:

El componente Navigation tiene tres partes principales:

NavController: Es responsable de navegar entre los destinos, es decir, las pantallas en tu app.
NavGraph: Realiza la asignaci√≥n de los destinos componibles a los que se navegar√°.
NavHost: Es el elemento componible que funciona como contenedor para mostrar el destino actual del NavGraph.

Uno de los conceptos fundamentales de la navegaci√≥n en una aplicaci√≥n Compose es la ruta. Una ruta es una cadena que corresponde a un destino. Esta idea es similar al concepto de una URL. As√≠ como una URL diferente se asigna a una p√°gina diferente en un sitio web, una ruta es una cadena que se asigna a un destino y sirve como su identificador √∫nico. Un destino es t√≠picamente un Composable √∫nico o un grupo de Composables que corresponden a lo que el usuario ve. La aplicaci√≥n Cupcake necesita destinos para la pantalla de inicio del pedido, la pantalla de selecci√≥n de sabores, la pantalla de fecha de recogida y la pantalla de resumen del pedido.

Un NavHost es un elemento componible que muestra otros destinos, seg√∫n una ruta determinada. Por ejemplo, si la ruta es Flavor, NavHost mostrar√° la pantalla para elegir el sabor de la magdalena. Si la ruta es Summary, la app mostrar√° la pantalla de resumen.

La sintaxis de NavHost es como cualquier otro elemento componible.

![Diagrama de NavHost](/img/T08/NavHost_sintax.png)


Se destacan dos par√°metros.

navController: Es una instancia de la clase NavHostController. Puedes usar este objeto a fin de navegar entre pantallas, por ejemplo, si llamas al m√©todo navigate() para navegar a otro destino. Puedes obtener el NavHostController si llamas a rememberNavController() desde una funci√≥n de componibilidad.
startDestination: Es una ruta de cadenas que define el destino que se muestra de forma predeterminada cuando la app muestra el NavHost por primera vez. En el caso de la app de Cupcake, esta deber√≠a ser la ruta Start.
Al igual que otros elementos componibles, NavHost tambi√©n toma un par√°metro modifier.

Nota: NavHostController es una subclase de la clase NavController que proporciona funciones adicionales para usar con un elemento componible NavHost.

Presta atenci√≥n a la firma del Cupcake que ya trae de f√°brica algunas cuestiones clave

```kotlin
@Composable
fun CupcakeApp(
    viewModel: OrderViewModel = viewModel(),
    navController: NavHostController = rememberNavController()
) 
...
```


Within the content function of a NavHost, you call the composable() function. The composable() function has two required parameters.

route: A string corresponding to the name of a route. This can be any unique string. You'll use the name property of the CupcakeScreen enum's constants.
content: Here you can call a composable that you want to display for the given route.
You'll call the composable() function once for each of the four routes.

Note: The composable() function is an extension function of NavGraphBuilder.


El truquito este tiene alternativas...

```kotlin

            composable(route = CupcakeScreen.Flavor.name) {
                val context = LocalContext.current
                SelectOptionScreen(
                    subtotal = uiState.price,
                    options = DataSource.flavors.map { id -> context.resources.getString(id) }
                )

            }
```

As√≠ enganchamos Enums y recursos string.xml

```kotlin
enum class CupcakeScreen(@StringRes val title: Int) {
    Start(title = R.string.app_name),
    Flavor(title = R.string.choose_flavor),
    Pickup(title = R.string.choose_pickup_date),
    Summary(title = R.string.order_summary)
}
```

El bot√≥n Up solo debe mostrarse si hay un elemento componible en la pila de actividades. Si la app no tiene pantallas en la pila de actividades (es decir, si se muestra StartOrderScreen), no deber√≠a mostrarse el bot√≥n Up. Para verificar esto, necesitas una referencia a la pila de actividades.

Convierte el t√≠tulo actual de la pantalla en un valor de CupcakeScreen. Debajo de la variable backStackEntry crea una variable utilizando val llamada currentScreen igual al resultado de llamar la funci√≥n de clase valueOf() de CupcakeScreen, y pasa la ruta del destino de backStackEntry. Usa el operador elvis para proporcionar un valor predeterminado de CupcakeScreen.Start.name.

```kotlin
val backStackEntry by navController.currentBackStackEntryAsState()
val currentScreen = CupcakeScreen.valueOf(
    backStackEntry?.destination?.route ?: CupcakeScreen.Start.name
)
```

https://developer.android.com/jetpack/compose/navigation.html
https://developer.android.com/guide/navigation/navigation-principles.html
https://developer.android.com/codelabs/jetpack-compose-navigation.html
https://material.io/design/navigation/understanding-navigation.html

> [!NOTE]
> La parte de test the Cupcake App la dejamos fuera de momento ya, aunque interesante, no es lo m√°s core ahora mismo.

Tambi√©n en el tutorial nos habla de los **Intents** para compartir datos entre apps, de momento quedaros con la idea de que son "mensajes" que se env√≠an entre componentes de Android (Activities, Services, Broadcast Receivers) para solicitar acciones o compartir datos. Pero no es el foco ahora mismo.

La entrega estar√° asociada a la pr√°ctica de **Practice: Add navigation** del codelab.

Para tener nuestro git preparado recuerda el trucazo, mejor si lo ejecutamos desde nuestra carpeta de AndroidStudioProjects o similar:

```bash
git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-lunch-tray
cd basic-android-kotlin-compose-training-lunch-tray
git checkout starter
git remote rename origin upstream
gh repo create YourMovilOrganization/YourRepoName --private --source=. --remote=origin
```

Ahora sin abandonar la terminal vamos a hacer un truco un poco üè¥‚Äç‚ò†Ô∏è*piratilla*üè¥‚Äç‚ò†Ô∏è , no hag√°is esto en proyectos serios, pero para nuestras pr√°cticas es √∫til. Este truco borra la rama main original del codelab y crea una nueva main con el contenido del starter, de esta forma evitamos tener que hacer merges raros:

```bash
git branch -D main
git checkout -b main
git add .
git commit -m "Initial commit from starter into main"
git push origin main
```

