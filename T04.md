# T04-Estado, TextField, Elevación de Estado, Switch, RadioButton

## Introducción

[cite\_start]Hemos visto cómo diseñar una pantalla estática mediante Compose, pero el usuario tendrá que interactuar con la App introduciendo datos y seleccionando opciones[cite: 10670]. [cite\_start]Veremos cómo tendremos que mantener el estado de las diferentes opciones del usuario para trabajar con Compose[cite: 10671]. [cite\_start]Es muy importante asimilar el patrón necesario para trabajar con estados de los diferentes elementos componibles[cite: 10672].

Vamos a seguir los codeLabs de Google, pero tenemos información más completa en los siguientes artículos:

  * [cite\_start][https://www.develou.com/android-textfield-en-compose/](https://www.develou.com/android-textfield-en-compose/) [cite: 10674]
  * [cite\_start][https://www.develou.com/android-estado-en-compose/](https://www.develou.com/android-estado-en-compose/) [cite: 10675]
  * [cite\_start][https://www.develou.com/switch-en-compose/](https://www.develou.com/switch-en-compose/) [cite: 10676]
  * [cite\_start][https://developer.android.com/develop/ui/compose/state?hl=es-419](https://developer.android.com/develop/ui/compose/state?hl=es-419) [cite: 10677]
  * [cite\_start][https://developer.android.com/codelabs/jetpack-compose-state?hl=es-419\#4](https://developer.android.com/codelabs/jetpack-compose-state?hl=es-419#4) [cite: 10678]

## Estado

[cite\_start]El "estado" de una app es cualquier valor que puede cambiar con el tiempo[cite: 10680]. [cite\_start]Esta es una definición muy amplia y abarca desde una base de datos hasta una variable de una clase[cite: 10681]. [cite\_start]Todas las apps para Android muestran un estado al usuario[cite: 10682].

Estos son algunos ejemplos de estado de las apps para Android:

  * [cite\_start]Los mensajes más recientes recibidos en una app de chat[cite: 10684].
  * La foto de perfil del usuario.
  * [cite\_start]La posición de desplazamiento en una lista de elementos[cite: 10685].

[cite\_start]**Idea clave:** El estado determina qué se muestra en la IU en un momento determinado[cite: 10687].

[placeholder $imagen.hombre\_interactuando\_con\_UI]

## Eventos

Los eventos son entradas generadas desde el interior o el exterior de una App, como las siguientes:

  * [cite\_start]El usuario que interactúa con la IU, por ejemplo, presionando un botón, escribe en un campo de texto, hace scroll en la pantalla... [cite: 10690]
  * [cite\_start]Otros factores, como los sensores que envían un valor nuevo o las respuestas de la red... [cite: 10691]

[cite\_start]Si bien el estado de la App ofrece una descripción de lo que se mostrará en la IU, los eventos son el mecanismo mediante el cual cambia el estado, lo que genera cambios en la IU[cite: 10692].

**Idea clave:** El estado **es**. [cite\_start]Los eventos **suceden**[cite: 10693].

[cite\_start]En todas las apps para Android, hay un bucle de actualización principal de la IU[cite: 10694]:

1.  [cite\_start]**Evento:** El usuario o alguna otra parte del programa generan un evento[cite: 10695].
2.  [cite\_start]**Estado de actualización:** Un controlador de eventos cambia el estado que usa la IU[cite: 10696].
3.  [cite\_start]**Estado de visualización:** Se actualiza la IU para mostrar el estado nuevo[cite: 10697].

[placeholder $imagen.diagrama\_bucle\_actualizacion\_UI\_con\_recomposicion]

### Recomposición

[cite\_start]Una recomposición se genera cuando Jetpack Compose vuelve a ejecutar los elementos componibles que pueden haberse modificado en respuesta a cambios de estado y, luego, actualiza la composición para reflejar los cambios[cite: 10704].

### MutableState

Tenemos una serie de clases que permiten a Compose observar si hay cambios. [cite\_start]Vamos a ver la clase `MutableState`[cite: 10706].

[placeholder $imagen.diagrama\_funcionamiento\_MutableState\_con\_ejemplo\_contador]

-----

### Auto import

Para que Android Studio importe automáticamente las librerías al vuelo y ahorremos tiempo, activa la opción en `File > Settings > Editor > General > Auto Import`.

[placeholder $imagen.configuracion\_auto\_import\_en\_Android\_Studio]

-----

### Ejercicio 1

Crea un nuevo proyecto. Vamos a seguir el codelab de Google para aprender el Patrón necesario:
[cite\_start][https://developer.android.com/codelabs/basic-android-kotlin-compose-using-state](https://developer.android.com/codelabs/basic-android-kotlin-compose-using-state) [cite: 10761]

[placeholder $imagen.app\_calculadora\_de\_propinas\_resultado\_final]

Ten en cuenta que tienes que hacer un checkout a la rama de `starter` para empezar.

[placeholder $imagen.menu\_git\_branches\_en\_android\_studio]
[placeholder $imagen.seleccion\_rama\_remota\_starter\_en\_git]

El siguiente vídeo explica el anterior codelab por si aún no os ha quedado claro:
[cite\_start][https://www.youtube.com/watch?v=y6wHf2JLTMg](https://www.youtube.com/watch?v=y6wHf2JLTMg) [cite: 10787]

[placeholder $imagen.miniatura\_video\_que\_es\_el\_estado\_en\_compose]

[placeholder $imagen.logo\_kotlin\_con\_enlace\_a\_articulo\_de\_delegacion\_de\_propiedades]

**Resumen de aprendizaje:**

  * Manejo de recursos de `strings.xml`.
  * Formato posicional en String.
  * Manejar `TextField`.
  * Manejar el estado de `TextField`: `mutableStateOf`.
  * Usar la delegación mediante la función `remember`.
  * Seleccionar el tipo de teclado para el `TextField`.
  * Añadir `label` al `TextField`.
  * La clase `NumberFormat`, que permite trabajar con formatos de número para diferentes países.
  * Utilizar el patrón de **Elevación de Estado**.
  * Delegación de propiedades de Kotlin.

-----

### Ejercicio 2

Seguimos con la misma app en la que veremos propiedades extra del `TextField`.

[cite\_start][https://developer.android.com/codelabs/basic-android-kotlin-compose-calculate-tip](https://developer.android.com/codelabs/basic-android-kotlin-compose-calculate-tip) [cite: 10808]

[placeholder $imagen.app\_calculadora\_de\_propinas\_con\_switch\_y\_porcentaje]

**Resumen de aprendizaje:**

  * Establecer el botón de acción del teclado del `TextField`.
  * Manejar `Switch`.
  * Recordar el estado ante reconstrucciones de la pantalla.
  * Composables sin estado.
  * Agrega compatibilidad con la orientación horizontal mediante `rememberScrollState()`.

### Mantener el estado ante reconstrucciones

[cite\_start]Aunque no lo indica el codelab, puede que te hayas fijado que cuando rotas la app, pierdes los datos introducidos por el usuario[cite: 10822]. [cite\_start]Es debido a que la Activity es destruida e iniciada de nuevo, por lo que los datos son iniciados[cite: 10823].

[cite\_start]Puedes mantener el estado cambiando la función `remember` por `rememberSaveable`[cite: 10824].

```kotlin
var amountInput by rememberSaveable { mutableStateOf("") }
```

Prueba que cuando rotas no pierdes los datos.

-----

### RadioButton

El `RadioButton` nos permite seleccionar una opción entre varias. [cite\_start]Para definirlo, lo haremos sobre un `Row` o `Column` según cómo queramos mostrarlo, y cada elemento individual mediante un `Row` donde creamos el `RadioButton` y el `Text` con el texto que los representa[cite: 10831].

La mejor forma de diseñarlo es:

  * Crear una lista de `String` con las opciones.
  * Recorremos la lista y definimos cada `RadioButton`.

[cite\_start]Tenemos un ejemplo de su definición en Material3: [RadioButton Material3](https://www.composables.com/material3/radiobutton) [cite: 10835]

[placeholder $imagen.codigo\_ejemplo\_radiobutton\_en\_compose\_con\_anotaciones]

La función para crear un `RadioButton` vertical podría ser:

  * Crea un radiobutton para cada opción de la lista. [cite\_start]Es conveniente que la lista de texto esté en `strings.xml` como un array de strings [cite: 10873-10874].
  * La lista la obtenemos desde los recursos. [cite\_start]Ejemplo: `val radioOptions = stringArrayResource(R.array.operaciones).toList()` [cite: 10875-10876].

<!-- end list -->

```kotlin
/**
* @param listaOpciones lista de opciones
* @param opcionSeleccionada opción seleccionada
* @param onOptionSelected función que se ejecuta cuando se selecciona una opción
*/
@Composable
fun RowRadioButtonCompose(
    listaOpciones: List<String>,
    opcionSeleccionada: String,
    onOptionSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .selectableGroup(),
        horizontalArrangement = Arrangement.SpaceAround
    ) {
        listaOpciones.forEach { operation ->
            Row(
                modifier = Modifier
                    .weight(1f)
                    .selectable(
                        selected = opcionSeleccionada == operation,
                        onClick = { onOptionSelected(operation) },
                        role = Role.RadioButton
                    )
                    .padding(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                RadioButton(
                    selected = opcionSeleccionada == operation,
                    onClick = null // El clic se maneja en el Row
                )
                Text(
                    text = operation,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}
```

-----

### Ejercicio 3: Calculadora

1.  **Crea un nuevo proyecto** llamado `T04Ejercicio3` con tu nombre en el `Package name`.

    [placeholder $imagen.dialogo\_new\_project\_calculadora]

2.  **Activa el control de versiones** (`VCS > Enable Version Control Integration...`).

    [placeholder $imagen.menu\_vcs\_enable\_version\_control]

3.  **Realiza el primer commit** con el mensaje "Inicio Ejercicio 1".

    [placeholder $imagen.ventana\_de\_commit\_inicial]

4.  **Crea un nuevo repositorio** en tu organización de GitHub con el mismo nombre y asócialo.

    [placeholder $imagen.ventana\_git\_remotes]

5.  **Realiza un Push** y comprueba que se sube correctamente.

6.  **Realiza suficientes commits** para que se vea la evolución en el tiempo.

7.  **Crea un nuevo fichero de Kotlin** llamado `Ejercicio3Calculadora`.

    [placeholder $imagen.crear\_nuevo\_fichero\_kotlin\_calculadora]

**El objetivo:**
Crear una calculadora donde el usuario introduce valores y selecciona la operación mediante un `RadioButton`.

  * Cuando se seleccione la operación, muestra el resultado y se cambia el icono.
  * Si no hay valores, el resultado muestra "0".
  * Realiza suficientes commits en el proyecto para que se vea la evolución.
  * Documenta el código.
  * Los strings tienen que estar en `strings.xml`.

[placeholder $imagen.resultado\_final\_calculadora\_con\_diferentes\_operaciones]

[placeholder $imagen.layout\_calculadora\_con\_anotaciones\_de\_diseno]

Será necesario que:

1.  El teclado sea de tipo numérico, al introducir `num1` permita pasar al `num2` y en `num2` permita cerrar el teclado.

    [placeholder $imagen.teclado\_numerico\_con\_botones\_siguiente\_y\_listo]

2.  Puedes utilizar `OutlinedTextField` en vez de `TextField`.

3.  Para mantener el estado, utiliza el patrón de **Elevación de Estado**.

4.  Utiliza nuevas funciones Composable en vez de crear los `TextField` directamente.

5.  El icono ocupará lo que queda de pantalla. Para ello, podemos darle un `weight(1f)` dentro de la `Column`.

    ```kotlin
    Icon(
        imageVector = icon,
        contentDescription = "Operación seleccionada",
        modifier = Modifier
            .weight(1f)
    )
    ```

6.  En caso de giro de pantalla, se mantienen los valores (recuerda usar `rememberSaveable`).

    [placeholder $imagen.calculadora\_en\_modo\_horizontal]

7.  Para el diseño del `RadioButton`, Google nos recomienda usarlo como indica el siguiente ejemplo: [https://www.composables.com/material3/radiobutton](https://www.composables.com/material3/radiobutton)

    [placeholder $imagen.codigo\_ejemplo\_radiobutton\_en\_compose\_con\_anotaciones]

8.  Para poder delegar el estado, tendréis que crear un método al que le pasamos el estado actual. La firma del método puede ser:

    ```kotlin
    @Composable
    fun OperacionRadioButton(
        listaOpciones: List<String>,
        operacionSeleccionada: String,
        onOptionSelected: (String) -> Unit,
        modifier: Modifier = Modifier
    )
    ```

9.  Puedes ver en el ejemplo que utiliza la **desestructuración** de Kotlin. Puedes revisar este concepto en: [https://www.develou.com/desestructuracion-en-kotlin/](https://www.develou.com/desestructuracion-en-kotlin/)

10. Define un array de string en `strings.xml` y recupéralo con `stringArrayResource(R.array.operaciones).toList()`.

    [placeholder $imagen.definicion\_string\_array\_en\_strings\_xml]