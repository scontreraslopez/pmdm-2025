# T10 - Coroutines. Bases de Datos con Room y DataStore

## Índice

- [Introducción](#introducción)
- [Coroutines](#coroutines)
- [Persistencia de Datos en Android: Room y DataStore](#persistencia-de-datos-en-android-room-y-datastore)

## Introducción

> [!NOTE]
> Aviso semipresencial: Esta unidad no se evaluará en el examen de la primera evaluación. Se delega a la segunda evaluación para balancear la carga de contenidos.

## Coroutines

Las coroutines son una característica de Kotlin que permite manejar operaciones asíncronas de manera más sencilla y eficiente. Facilitan la escritura de código que realiza tareas en segundo plano sin bloquear el hilo principal, lo que es especialmente útil en aplicaciones móviles donde la experiencia del usuario es crucial.

Se trata de hilos ligeros que pueden suspender su ejecución sin bloquear el hilo en el que se ejecutan, permitiendo así una mejor gestión de los recursos y una mayor capacidad de respuesta en las aplicaciones.

Para tener una primera familiarización con las coroutines en Android, seguiremos los siguientes recursos:

- [Video: Introducción a las Coroutines en Android](https://www.youtube.com/watch?v=4Vh36EnFs4E)
- [Codelab: Coroutines en Kotlin Playground](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground)
- [Codelab: Coroutines en Android Studio](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-android-studio) --> De este último podemos omitir la parte 7 (Testing Coroutines) para no alargar demasiado.

### 1. El Problema: El Hilo Principal (Main Thread)

Primero, la base: toda app de Android tiene un **hilo principal (Main Thread o UI Thread)**.

Piensa en este hilo como un único operario en una cadena de montaje. Su *única* tarea es dibujar la interfaz de usuario (la UI de Compose), gestionar animaciones y responder a eventos (como clics).

Si a este operario le pides que, además de dibujar la pantalla 60 veces por segundo, se vaya al almacén a buscar datos (una llamada a red o a la base de datos), la cadena de montaje (la UI) se **bloquea**. La app se congela y el usuario recibe el temido diálogo **Application Not Responding** (ANR).

![ANR imagen](/img/T10/ANR_1.webp)

### 2. La Solución: Coroutines

Las coroutines son, sencillamente, una forma de lanzar tareas en *otros hilos* (segundo plano) para no bloquear al operario principal (Main Thread).

Son "hilos ligeros" (lightweight threads). Crear un hilo tradicional (Thread) es "caro" para el sistema, pero puedes lanzar miles de coroutines sin problemas.

Para usarlas en Android, necesitarás tres conceptos clave: **suspend**, **CoroutineScope** y **Dispatchers**.

-----

### 3. Funciones Suspendidas (El "Qué")

Una función marcada con la palabra clave `suspend` es una **función que puede ser pausada y reanudada** sin bloquear el hilo en el que se ejecuta.

Cuando una función `suspend` se llama desde una coroutine, puede "suspenderse" en puntos específicos (por ejemplo, durante una llamada a red) y ceder el control a otras coroutines mientras espera. Esto permite que el hilo principal siga respondiendo a la UI.

Eso sí, `suspend` es "contagioso": solo puedes llamar a funciones `suspend` desde otras funciones `suspend` o desde un constructor de coroutine (como `launch` o `async`).

```kotlin
suspend fun miFuncionSuspendida() {
    // Hacer algo
}

fun miFuncionNormal() {
    miFuncionSuspendida() // Error: no se puede llamar a una función suspendida
}

// Correcto: llamar desde una coroutine
fun lanzarCoroutine() {
    CoroutineScope(Dispatchers.Main).launch {
        miFuncionSuspendida() // OK
    }
}
```

-----

### 4. CoroutineScope (El "Quién" y "Cuándo")

Un `CoroutineScope` (Ámbito) define el **ciclo de vida** de una coroutine. Es el "dueño" de la coroutine.

- **¿Qué es?** Es un objeto que controla cuándo deben empezar y, sobre todo, cuándo deben **cancelarse** las coroutines.
- **¿Por qué es vital?** Imagina que lanzas una llamada a red en una pantalla. El usuario se cansa de esperar y cierra esa pantalla. Si la coroutine sigue viva, intentará actualizar una pantalla que ya no existe (¡crash!) o seguirá consumiendo batería en segundo plano (¡mal!).
- **El Scope en Compose:** El `CoroutineScope` soluciona esto. Si el Scope se cancela (porque la pantalla se destruye o el ViewModel se limpia), todas las coroutines que lanzó se cancelan automáticamente.
- **En Jetpack Compose:**
  - **`viewModelScope`**: Es el que más usarás. Cada `ViewModel` tiene el suyo. Está atado al ciclo de vida del ViewModel; si el ViewModel se destruye, las coroutines se cancelan.
  - **`rememberCoroutineScope()`**: Se usa dentro de un Composable (ej. en el `onClick` de un `Button`) para lanzar una coroutine ligada al ciclo de vida de ese Composable en el árbol de la UI.

### 5. Dispatchers (El "Dónde")

El `Dispatcher` (Despachador) le dice a la coroutine **en qué hilo debe ejecutarse**. Es el que gestiona el "salto" entre hilos.

Hay 3 principales que debemos conocer:

- **`Dispatchers.Main`**: El hilo principal. **Obligatorio** usarlo siempre que vayas a tocar la UI. En Compose, esto significa **actualizar un `State`** (ej. `miEstado.value = ...`).
- **`Dispatchers.IO`**: (Input/Output). Un pool de hilos optimizado para operaciones de **Entrada/Salida**. Es el que deben usar *siempre* para acceder a la red (Retrofit) o a la base de datos (Room).
- **`Dispatchers.Default`**: Un pool de hilos optimizado para tareas "pesadas" de **CPU**. Por ejemplo, ordenar una lista gigante, calcular un fractal o desencriptar datos.

-----

### 6. El Flujo Completo (La Receta)

Ahora juntemos todo en el contexto de Compose y un `ViewModel`:

1. **El Usuario hace clic (UI Thread).**
2. El `onClick` llama a una función en el `ViewModel`.
3. El `ViewModel` lanza la coroutine en su ámbito: `viewModelScope.launch { ... }` (Este `launch` arranca por defecto en `Dispatchers.Main`).
4. Dentro de la coroutine, saltamos al hilo de I/O para el trabajo pesado usando `withContext(Dispatchers.IO)`:

```kotlin
// (Dentro del ViewModel)
    fun cargarDatos() {
    // 3. Lanzamos Coroutine en el scope principal (Main)
        viewModelScope.launch { 
            // 4. Saltamos a un hilo secundario (IO) para la tarea pesada
            val resultado = withContext(Dispatchers.IO) {
                miRepositorio.getDatosDeLaApi() // Esto tarda, pero no bloquea la UI
            }
            
            // 5. Al salir de withContext, vuelve automáticamente al hilo Main
            _miEstado.value = resultado // Actualizamos el State de Compose
        }
    }
```

**"El `State` de Compose SOLO se modifica desde `Dispatchers.Main`"**. Gracias a `viewModelScope` y `withContext`, este salto de hilos (Main -> IO -> Main) es automático, seguro y limpio, evitando *crashes* y ANRs.

## Persistencia de Datos en Android: Room y DataStore

Vamos a seguir los codelabs: [https://developer.android.com/courses/android-basics-compose/unit-6](https://developer.android.com/courses/android-basics-compose/unit-6)

Empezamos con el de SQL

```bash
git clone https://github.com/google-developer-training/android-basics-kotlin-sql-basics-app.git
git checkout compose
```

A continuación ya podemos abrirlo con Android Studio. Lo más interesante de este codelab es la parte del **App Inspection**, el resto es un refresco rápido de SQL. Recuerda que los diferentes motores de bases de datos (SQLite, MySQL, PostgreSQL, etc.) usan SQL similar pero no idéntico, es lo que llamamos "dialectos".

### 7. Kotlin Flows (El Flujo de Datos)

Hasta ahora hemos visto cómo usar coroutines para hacer tareas de "un solo disparo" (One-shot requests): pides un dato, esperas y te lo devuelven.

Pero, **¿qué pasa si los datos cambian con el tiempo?**

Imagina un chat en tiempo real o una app de bolsa. No quieres pedir el precio del Bitcoin una vez; quieres establecer una conexión y que te vayan llegando las actualizaciones automáticamente. Aquí entra **Kotlin Flow**.

#### La Analogía: La Tubería

Utilizaremos la analogía de la tubería, la misma que verás en los vídeos oficiales de Google sobre Flow.

- **Suspend Function (`suspend`)**: Es como pedir una pizza. Llamas, esperas, te la traen y se acaba la interacción.
- **Flow**: Es como abrir un grifo (o una tubería). Una vez abierto, el agua (los datos) fluye continuamente hasta que cierras el grifo.

#### ¿Por qué es vital para Room y DataStore?

En Android moderno, **Room** y **DataStore** se llevan genial con Flow.
Si en tu base de datos (DAO) devuelves un `Flow<List<Usuario>>` en lugar de una `List<Usuario>` normal, ocurre la magia:

> [!NOTE]
> **Cada vez que insertes, borres o actualices un dato en la tabla, Room emitirá automáticamente la nueva lista actualizada a través del Flow.**

¡Ya no tienes que volver a consultar la base de datos manualmente para refrescar la pantalla!

#### StateFlow: El puente hacia Compose

En la arquitectura MVVM moderna, usamos una variante especial llamada `StateFlow`.
Mientras que un `Flow` normal es "frío" (no hace nada hasta que alguien escucha), el `StateFlow` es un contenedor de estado que **siempre tiene un valor actual** y notifica a la UI cuando cambia.

Es el sustituto moderno del antiguo `LiveData`.

#### La Receta con Flow (Observer Pattern)

El patrón cambia ligeramente respecto a las coroutines normales:

1. **Room (DAO):** Devuelve un `Flow`.
2. **ViewModel:** Convierte ese Flow en un `StateFlow` para que la UI lo pueda leer fácilmente.
3. **Compose (UI):** "Recolecta" (`collect`) ese estado.

<!-- end list -->

```kotlin
// 1. En el DAO (Room)
@Query("SELECT * FROM usuarios")
fun getUsuarios(): Flow<List<Usuario>> // <-- Nota que no lleva 'suspend'

// 2. En el ViewModel
val usuariosState: StateFlow<List<Usuario>> = repositorio.getUsuarios()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )

// 3. En la UI (Compose)
@Composable
fun PantallaUsuarios(viewModel: MiViewModel) {
    // collectAsState convierte el flujo en un State de Compose
    val listaUsuarios by viewModel.usuariosState.collectAsState() 
    
    LazyColumn {
        items(listaUsuarios) { usuario ->
            Text(text = usuario.nombre)
        }
    }
}
```

> [!TIP]
> **Ojo al dato:** Fíjate que en el DAO, cuando devolvemos `Flow`, **no** usamos la palabra clave `suspend`. El Flow en sí mismo es asíncrono y "frío" (no hace nada hasta que alguien lo recolecta, `.collect()`). Es decir, no bloquea nada por el mero hecho de existir.

-----

Respecto al tema de Room, tenemos tres componentes principales:

- Entity: Representa una tabla en la base de datos.
- DAO (Data Access Object): Define los métodos para acceder a la base de datos.
- Database: La base de datos en sí, que une las entidades y los DAOs.

![Room Components](/img/T10/room_components.png)

Para el tema de las dependencias, debemos hacerlo desde el archivo `build.gradle` a nivel de módulo (app).

![build.gradle.kts file](/img/T10/build_gradle.png)

Y aquí ya planchamos las dependencias necesarias para Room:

![Room dependencies](/img/T10/room_dependencies.png)

> [!NOTE]
> Existe otra sintaxis para añadir las dependencias a Gradle más moderna que lo que hace es delegar las versiones a un archivo `gradle/libs.versions.toml`, pero para no complicar más el asunto, usaremos la forma clásica. Por si os lo tropezáis, esto se llama **Version Catalogs**.

**The Entity:**

Un clase [Entity](https://developer.android.com/reference/androidx/room/Entity) es una representación de una tabla en la base de datos. Cada instancia de la clase representa una fila en esa tabla. Se encarga de mapear los campos de la clase a las columnas de la tabla y está anotada con `@Entity`. Cada campo de la clase corresponde (salvo indicación contraria) a una columna en la tabla de la base de datos. Necesita una clave primaria, que se indica con `@PrimaryKey`.

Las entidades se definen como clases de datos (`data class`) en Kotlin. Se puede especificar el nombre de la tabla usando el parámetro `tableName` en la anotación `@Entity`. Del mismo modo se puede especificar el nombre de las columnas usando la anotación `@ColumnInfo(name = "nombre_columna")`.

Para crear índices en las tablas, se usa el parámetro `indices` en la anotación `@Entity`, que recibe un array de `Index`. Del mismo modo, se pueden definir claves foráneas usando el parámetro `foreignKeys`.

```kotlin
import androidx.room.PrimaryKey

@Entity(tableName = "items")
data class Item(
    @PrimaryKey
    val id: Int,
    ...
)
```

**The DAO:**

El [DAO (Data Access Object)](https://developer.android.com/reference/androidx/room/Dao) es patrón de diseño que, apoyado en una interfaz o clase abstracta, define los métodos para acceder a la base de datos. Se encarga de mapear las operaciones de la base de datos (como consultas, inserciones, actualizaciones y eliminaciones) a métodos en Kotlin.

Así el DAO oculta los detalles de implementación de la base de datos, proporcionando una interfaz limpia y fácil de usar para interactuar con los datos. Esto nos permitiría modificar la implementación de la base de datos sin afectar al resto de la aplicación. Por lo tanto **la aplicación no interactúa directamente con la base de datos, sino a través del DAO**.

Sus anotaciones principales son:

- `@Dao`: Marca la interfaz o clase como un DAO.
- `@Insert`: Marca un método para insertar datos en la base de datos.
- `@Update`: Marca un método para actualizar datos existentes.
- `@Delete`: Marca un método para eliminar datos.
- `@Query`: Marca un método para ejecutar una consulta SQL personalizada.

Uno de los parámetros más importantes de las anotaciones es la estrategia de conflicto (`onConflict`), que define qué hacer cuando se intenta insertar un dato que ya existe en la base de datos. Las estrategias comunes son:

- `OnConflictStrategy.REPLACE`: Reemplaza el dato existente.
- `OnConflictStrategy.IGNORE`: Ignora la nueva inserción.

Fíjate como declaramos estas funciones como `suspend`, ya que son operaciones que pueden tardar y no queremos bloquear el hilo principal.

```kotlin
@Insert(onConflict = OnConflictStrategy.IGNORE)
suspend fun insert(item: Item)
```

Para el delete, necesitamos pasarle el objeto completo que queremos borrar por lo que típicamente necesitaremos acompañarla de una función para buscar un objeto por su id o clave primaria.

```kotlin
@Delete
suspend fun delete(item: Item)
@Query("SELECT * FROM items WHERE id = :itemId")
suspend fun getItemById(itemId: Int
): Item?
```

Aún mejor, podemos usar Flow para que nos vaya notificando de los cambios en la base de datos.

```kotlin
@Query("SELECT * from items WHERE id = :id")
fun getItem(id: Int): Flow<Item>
```

Fíjate que el parámetros `id` en la consulta SQL se indica con `:id`, que es el mismo nombre que el parámetro de la función precedido de dos puntos (:). Room hace el mapeo automáticamente.

Las consecuencias de usar Flow en el DAO es que cada vez que se modifique la tabla, Room emitirá automáticamente el nuevo valor a través del Flow. También no necesitamos usar `suspend` en estas funciones, ya que el Flow es asíncrono por naturaleza.

Que quiero que la UI refresque la lista automáticamente cada vez que se inserte, borre o modifique un elemento. Sencillo, devolveré un Flow con la lista completa:

```kotlin
@Query("SELECT * from items ORDER BY name ASC")
fun getAllItems(): Flow<List<Item>>
```

**The Database:**

La clase [Database](https://developer.android.com/reference/androidx/room/Database) es la representación de la base de datos en sí. Es una clase abstracta que extiende de `RoomDatabase` y está anotada con `@Database`. Esta clase sirve como punto de acceso principal a la base de datos y proporciona los DAOs necesarios para interactuar con las tablas.

Su implementación más natural es como un singleton, para asegurar que solo existe una instancia de la base de datos en toda la aplicación. Esto es importante para evitar conflictos y asegurar la integridad de los datos. Como hemos dicho que es una clase abstracta, crearemos dentro de ella un compañero `companion object` que contendrá el método para obtener la instancia única de la base de datos.

El proceso general para recuperar la instancia de `RoomDatabase` es como sigue:

- Crea una `public abstract class` que extienda de `RoomDatabase`. Este será el contenedor de la base de datos y es abstracto porque Room generará la implementación concreta en tiempo de compilación.
- Anota la clase con `@Database`, especificando las entidades (tablas) y la versión de la base de datos.
- Dentro de la clase, define métodos abstractos para cada DAO que necesites. Room generará las implementaciones de estos métodos.
- Implementa un `companion object` con un método `getDatabase(context: Context)` que devuelva la instancia singleton de la base de datos.
- Usa `Room.databaseBuilder()` para construir la base de datos si aún no existe. En caso contrario, devuelve la instancia existente.

A la instancia la anotaremos con `@Volatile` para asegurar que las escrituras en esta variable son visibles inmediatamente para otros hilos.

Si debemos implementar alguna migración de versión, lo haremos en el builder con `.addMigrations(...)`. Referencia en [https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929](https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929). Si no, podemos usar `.fallbackToDestructiveMigration()` para que simplemente borre y recree la base de datos si detecta un cambio de versión.

Ejemplo básico de codelab:

```kotlin

/**
* Database class with a singleton Instance object.
*/
@Database(entities = [Item::class], version = 1, exportSchema = false)
abstract class InventoryDatabase : RoomDatabase() {

    abstract fun itemDao(): ItemDao

    companion object {
        @Volatile
        private var Instance: InventoryDatabase? = null

        fun getDatabase(context: Context): InventoryDatabase {
            // if the Instance is not null, return it, otherwise create a new database instance.
            return Instance ?: synchronized(this) {
                Room.databaseBuilder(context, InventoryDatabase::class.java, "item_database")
                    .build()
                    .also { Instance = it }
            }
        }
    }
}
```

Esta plantilla básica la podemos adaptar a nuestras necesidades según el número de entidades y DAOs que tengamos.

Similar a como ocurre en Retrofit, aquí se nos plantea una disyuntiva arquitectónica: ¿inyección de dependencias con repositorio de verdad, o repositorio fake? El codelab opta por la primera opción, pero son bastantes pasos extra en especial si tenemos un viewModel (*supuesto inyección dependencias manual*): Interfaz repositorio, implementación repositorio, contenedor de dependencias manual, Application personalizada, registrarlo en el manifest, Factory para el ViewModel, etc. Si no vamos a hacer testing unitario, podemos optar por la segunda opción y simplificar mucho el código.

En el tema de Retrofit encontrarás (además del codelab de MarsPhoto y el de AppInventory en este tema) un ejemplo completo de inyección de dependencias manual con repositorio real. Así tienes las herramientas y utilizas lo que mejor se ajuste a tus necesidades. Que las buenas prácticas son buenas, pero la simplicidad (ajustada a esas necesidades) es una máxima tanto o más importante.

Pues solo faltaría ese Repositorio que haga de intermediario entre el DAO y el ViewModel.

```kotlin
object ItemRepository {

    // Referencia al DAO real de Room
    private lateinit var itemDao: ItemDao

    // Inicialización desde la base de datos
    fun init(database: ItemDatabase) {
        itemDao = database.itemDao()
    }

    // Exponemos el flujo de items
    val allItems: Flow<List<Item>> by lazy {
        itemDao.getAllItems()
    }

    suspend fun insert(item: Item) {
        itemDao.insert(item)
    }

    suspend fun delete(item: Item) {
        itemDao.delete(item)
    }

    suspend fun getItemById(id: Int): Item? {
        return itemDao.getItemById(id)
    }
}
```

> [!NOTE]
> En el codelab, en la parte de la funcionalidad de guardado crea los mappers para convertir entre el modelo de Room (la entitity), el modelo de dominio (data class) y el modelo de UI (data class UiState que se apoya en la anterior). Los crea dentro del viewModel como funciones de extensión.

Por último, para la entrega de esta parte, consiste exclusivamente en la entrega del codelab de **Bus Schedule** [https://developer.android.com/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app](https://developer.android.com/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app)

> [!IMPORTANT]
> La entrega consistirá en subir el proyecto completo a vuestro repositorio de GitHub. Se espera como poco 4 commits uno por cada sección del codelab.

Por último realizaremos los codelabs de DataStore: [https://developer.android.com/courses/pathways/android-basics-compose-unit-6-pathway-3](https://developer.android.com/courses/pathways/android-basics-compose-unit-6-pathway-3) Para estos no procede ninguna entrega, pero son interesantes para comprender esta manera de persistencia ligera de datos.
