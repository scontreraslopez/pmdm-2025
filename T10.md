# T10 - Coroutines. Bases de Datos con Room y DataStore

> [!WARNING]
> Este tema se está actualizando, susceptible de cambiar durante el próximo par de días.
> La parte de Coroutines ya está completa, así como los enlaces a los codelabs de Room y DataStore. Se complementará y se hablará de las tareas.

## Introducción

> [!NOTE]
> Aviso semipresencial: Esta unidad no se evaluará en el examen de la primera evaluación. Se delega a la segunda evaluación para balancear la carga de contenidos.

## Coroutines

Las coroutines son una característica de Kotlin que permite manejar operaciones asíncronas de manera más sencilla y eficiente. Facilitan la escritura de código que realiza tareas en segundo plano sin bloquear el hilo principal, lo que es especialmente útil en aplicaciones móviles donde la experiencia del usuario es crucial.

Se trata de hilos ligeros que pueden suspender su ejecución sin bloquear el hilo en el que se ejecutan, permitiendo así una mejor gestión de los recursos y una mayor capacidad de respuesta en las aplicaciones.

Para tener una primera familiarización con las coroutines en Android, seguiremos los siguientes recursos:

* [Video: Introducción a las Coroutines en Android](https://www.youtube.com/watch?v=4Vh36EnFs4E)
* [Codelab: Coroutines en Kotlin Playground](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground)
* [Codelab: Coroutines en Android Studio](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-android-studio) --> De este último podemos omitir la parte 7 (Testing Coroutines) para no alargar demasiado.

### 1. El Problema: El Hilo Principal (Main Thread)

Primero, la base: toda app de Android tiene un **hilo principal (Main Thread o UI Thread)**.

Piensa en este hilo como un único operario en una cadena de montaje. Su *única* tarea es dibujar la interfaz de usuario (la UI de Compose), gestionar animaciones y responder a eventos (como clics).

Si a este operario le pides que, además de dibujar la pantalla 60 veces por segundo, se vaya al almacén a buscar datos (una llamada a red o a la base de datos), la cadena de montaje (la UI) se **bloquea**. La app se congela y el usuario recibe el temido diálogo **Application Not Responding** (ANR).

![ANR imagen](/img/T10/ANR_1.webp)

### 2. La Solución: Coroutines

Las coroutines son, sencillamente, una forma de lanzar tareas en *otros hilos* (segundo plano) para no bloquear al operario principal (Main Thread).

Son "hilos ligeros" (lightweight threads). Crear un hilo tradicional (Thread) es "caro" para el sistema, pero puedes lanzar miles de coroutines sin problemas.

Para usarlas en Android, necesitarás tres conceptos clave: **suspend**, **CoroutineScope** y **Dispatchers**.

-----

### 3. Funciones Suspendidas (El "Qué")

Una función marcada con la palabra clave `suspend` es una **función que puede ser pausada y reanudada** sin bloquear el hilo en el que se ejecuta.

Cuando una función `suspend` se llama desde una coroutine, puede "suspenderse" en puntos específicos (por ejemplo, durante una llamada a red) y ceder el control a otras coroutines mientras espera. Esto permite que el hilo principal siga respondiendo a la UI.

Eso sí, `suspend` es "contagioso": solo puedes llamar a funciones `suspend` desde otras funciones `suspend` o desde un constructor de coroutine (como `launch` o `async`).

```kotlin
suspend fun miFuncionSuspendida() {
    // Hacer algo
}

fun miFuncionNormal() {
    miFuncionSuspendida() // Error: no se puede llamar a una función suspendida
}

// Correcto: llamar desde una coroutine
fun lanzarCoroutine() {
    CoroutineScope(Dispatchers.Main).launch {
        miFuncionSuspendida() // OK
    }
}
```

-----

### 4. CoroutineScope (El "Quién" y "Cuándo")

Un `CoroutineScope` (Ámbito) define el **ciclo de vida** de una coroutine. Es el "dueño" de la coroutine.

* **¿Qué es?** Es un objeto que controla cuándo deben empezar y, sobre todo, cuándo deben **cancelarse** las coroutines.
* **¿Por qué es vital?** Imagina que lanzas una llamada a red en una pantalla. El usuario se cansa de esperar y cierra esa pantalla. Si la coroutine sigue viva, intentará actualizar una pantalla que ya no existe (¡crash!) o seguirá consumiendo batería en segundo plano (¡mal!).
* **El Scope en Compose:** El `CoroutineScope` soluciona esto. Si el Scope se cancela (porque la pantalla se destruye o el ViewModel se limpia), todas las coroutines que lanzó se cancelan automáticamente.
* **En Jetpack Compose:**
  * **`viewModelScope`**: Es el que más usarás. Cada `ViewModel` tiene el suyo. Está atado al ciclo de vida del ViewModel; si el ViewModel se destruye, las coroutines se cancelan.
  * **`rememberCoroutineScope()`**: Se usa dentro de un Composable (ej. en el `onClick` de un `Button`) para lanzar una coroutine ligada al ciclo de vida de ese Composable en el árbol de la UI.

### 5. Dispatchers (El "Dónde")

El `Dispatcher` (Despachador) le dice a la coroutine **en qué hilo debe ejecutarse**. Es el que gestiona el "salto" entre hilos.

Hay 3 principales que debemos conocer:

* **`Dispatchers.Main`**: El hilo principal. **Obligatorio** usarlo siempre que vayas a tocar la UI. En Compose, esto significa **actualizar un `State`** (ej. `miEstado.value = ...`).
* **`Dispatchers.IO`**: (Input/Output). Un pool de hilos optimizado para operaciones de **Entrada/Salida**. Es el que deben usar *siempre* para acceder a la red (Retrofit) o a la base de datos (Room).
* **`Dispatchers.Default`**: Un pool de hilos optimizado para tareas "pesadas" de **CPU**. Por ejemplo, ordenar una lista gigante, calcular un fractal o desencriptar datos.

-----

### 6. El Flujo Completo (La Receta)

Ahora juntemos todo en el contexto de Compose y un `ViewModel`:

1. **El Usuario hace clic (UI Thread).**
2. El `onClick` llama a una función en el `ViewModel`.
3. El `ViewModel` lanza la coroutine en su ámbito: `viewModelScope.launch { ... }` (Este `launch` arranca por defecto en `Dispatchers.Main`).
4. Dentro de la coroutine, saltamos al hilo de I/O para el trabajo pesado usando `withContext(Dispatchers.IO)`:

```kotlin
// (Dentro del ViewModel)
    fun cargarDatos() {
    // 3. Lanzamos Coroutine en el scope principal (Main)
        viewModelScope.launch { 
            // 4. Saltamos a un hilo secundario (IO) para la tarea pesada
            val resultado = withContext(Dispatchers.IO) {
                miRepositorio.getDatosDeLaApi() // Esto tarda, pero no bloquea la UI
            }
            
            // 5. Al salir de withContext, vuelve automáticamente al hilo Main
            _miEstado.value = resultado // Actualizamos el State de Compose
        }
    }
```

**"El `State` de Compose SOLO se modifica desde `Dispatchers.Main`"**. Gracias a `viewModelScope` y `withContext`, este salto de hilos (Main -> IO -> Main) es automático, seguro y limpio, evitando *crashes* y ANRs.

## Persistencia de Datos en Android: Room y DataStore

Vamos a seguir los codelabs: [https://developer.android.com/courses/android-basics-compose/unit-6](https://developer.android.com/courses/android-basics-compose/unit-6)

Empezamos con el de SQL

```bash
git clone https://github.com/google-developer-training/android-basics-kotlin-sql-basics-app.git
git checkout compose
```

A continuación ya podemos abrirlo con Android Studio. Lo más interesante de este codelab es la parte del **App Inspection**, el resto es un refresco rápido de SQL. Recuerda que los diferentes motores de bases de datos (SQLite, MySQL, PostgreSQL, etc.) usan SQL similar pero no idéntico, es lo que llamamos "dialectos".

Respecto al tema de Room, tenemos tres componentes principales:

* Entity: Representa una tabla en la base de datos.
* DAO (Data Access Object): Define los métodos para acceder a la base de datos.
* Database: La base de datos en sí, que une las entidades y los DAOs.

![Room Components](/img/T10/room_components.png)

Para el tema de las dependencias, debemos hacerlo desde el archivo `build.gradle` a nivel de módulo (app).

![build.gradle.kts file](/img/T10/build_gradle.png)

Y aquí ya planchamos las dependencias necesarias para Room:

![Room dependencies](/img/T10/room_dependencies.png)

> [!NOTE]
> Existe otra sintaxis para añadir las dependencias a Gradle más moderna que lo que hace es delegar las versiones a un archivo `gradle/libs.versions.toml`, pero para no complicar más el asunto, usaremos la forma clásica. Por si os lo tropezáis.

Por último, para la entrega de esta parte, consiste exclusivamente en la entrega del codelab de **Bus Schedule** [https://developer.android.com/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app](https://developer.android.com/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app)

> [!IMPORTANT]
> La entrega consistirá en subir el proyecto completo a vuestro repositorio de GitHub. Se espera como poco 4 commits uno por cada sección del codelab.

Por último realizaremos los codelabs de DataStore: [https://developer.android.com/courses/pathways/android-basics-compose-unit-6-pathway-3](https://developer.android.com/courses/pathways/android-basics-compose-unit-6-pathway-3) Para estos no procede ninguna entrega, pero son interesantes para comprender esta manera de persistencia ligera de datos.

