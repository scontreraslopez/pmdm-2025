# T11 ‚Äì Integraci√≥n de APIs con Retrofit y Coroutines. Manejo de Intents en Android

## 1. El sistema de mensajer√≠a de Android: Intents

En el desarrollo nativo, los componentes de una aplicaci√≥n (como las *Activities* o los *Services*) no se invocan directamente instanciando sus clases. Android utiliza un **sistema de mensajer√≠a as√≠ncrona** llamado **Intent**. Un `Intent` es una descripci√≥n abstracta de una operaci√≥n que se va a realizar.

Seg√∫n el curr√≠culo oficial, debemos dominar las clases necesarias para la conexi√≥n y comunicaci√≥n, y los Intents son la piedra angular para ello. Esta secci√≥n cubrir√° los aspectos esenciales de los Intents en Android, no pretende ser un curso exhaustivo (como en casi todo hay mucho m√°s y mejor), pero s√≠ darte las bases para que puedas utilizarlos eficazmente en tus aplicaciones.

### 1.1. Tipos de Intents

Podemos clasificar los Intents en dos grandes grupos seg√∫n su prop√≥sito y especificidad:

#### A. Intents Expl√≠citos

Se utilizan para iniciar un componente espec√≠fico dentro de tu propia aplicaci√≥n. Se denominan "expl√≠citos" porque defines exactamente qu√© clase (Activity o Service) quieres arrancar. Son la base de la navegaci√≥n cl√°sica en Android.

**Ejemplo: Navegar de la `MainActivity` a `DetailActivity`**

```kotlin
val intent = Intent(this, DetailActivity::class.java)
startActivity(intent)
```

> [!NOTE]
> Esto lo ver√°s sobre todo si tienes la ¬øsuerte? de trabajar con proyectos legacy (view system / XML) o con c√≥digo Java antiguo. En proyectos modernos con Jetpack (**Navigation Compose**), la navegaci√≥n entre pantallas se gestiona con los Navigation Components que hemos visto (aunque los Intents expl√≠citos siguen siendo v√°lidos y √∫tiles en muchos casos).

#### B. Intents Impl√≠citos

No nombran un componente espec√≠fico, sino que declaran una **acci√≥n general** a realizar. El sistema Android busca entre todas las aplicaciones instaladas aquellas que tengan un *Intent Filter* capaz de manejar dicha acci√≥n. Esto es crucial para integrar nuestra app con el ecosistema (abrir mapas, compartir texto, hacer una llamada, etc.).

Como imaginar√°s, estos Intents son fundamentales para nosotros a la hora de consumir los servicios de otras apps o del sistema.

**Ejemplo: mandar un texto:**

```kotlin
    // Acci√≥n: ENVIAR algo (SEND)
    val sendIntent = Intent(Intent.ACTION_SEND).apply {
        // Importante: Definir el tipo de dato (MIME type)
        type = "text/plain"
        // El contenido a compartir
        putExtra(Intent.EXTRA_TEXT, "¬°Mira la nueva app del instituto! Desc√°rgala aqu√≠.")
    }

    // createChooser crea el men√∫ visual para elegir app (WhatsApp, Gmail, etc.)
    // y adem√°s protege si no hay ninguna app (aunque es raro no tener ninguna).
    val shareIntent = Intent.createChooser(sendIntent, "Compartir v√≠a...")
    context.startActivity(shareIntent)
```

#### C. Resumen de los tipos de Intents (TLDR)

Es importante aclarar la diferencia entre ambos tipos de Intents en funci√≥n del contexto de uso, dado que la evoluci√≥n de Android ha cambiado la forma en que navegamos entre pantallas. ¬°Android evoluciona rapid√≠simo y hay que estar al d√≠a!  

**Navegaci√≥n Interna (Dentro de tu App)**:

- En el pasado (Legacy/View System): Se usaban Intents Expl√≠citos para saltar de una pantalla a otra (de Activity a Activity). Era pesado y lento.
- En el presente (Jetpack Compose): Usamos Navigation Compose. Google recomienda una arquitectura de "Activity √önica" (Single Activity Architecture), donde la navegaci√≥n entre pantallas se gestiona intercambiando funciones `@Composable` de forma fluida dentro de la misma ventana, sin usar Intents.

**Navegaci√≥n Externa (Hacia otras Apps)**:

- Aqu√≠ los Intents (Impl√≠citos) siguen siendo los reyes indiscutibles. Da igual que uses tecnolog√≠a moderna o antigua; si quieres abrir la c√°mara, el mapa o compartir un texto con WhatsApp, necesitas un Intent.

### 1.2. Transferencia de datos entre Activities (Extras)

Un `Intent` puede transportar datos adicionales utilizando el m√©todo `putExtra()`, que funciona como un mapa de clave-valor. Estos datos se recuperan en la actividad de destino a trav√©s de `intent.extras`.

**Enviar datos:**

```kotlin
val intent = Intent(this, UserProfileActivity::class.java).apply {
    putExtra("USER_ID", 42)
    putExtra("USER_NAME", "Alice")
}
startActivity(intent)
```

**Recibir datos (en `UserProfileActivity`):**

```kotlin
val userId = intent.getIntExtra("USER_ID", -1) // -1 es el valor por defecto
val userName = intent.getStringExtra("USER_NAME")
```

### 1.3. Pr√°ctica guiada: IES Severo Ochoa Intents

Para practicar el uso de Intents, vamos a hacer una peque√±a aplicaci√≥n monopantalla del IES Severo Ochoa que nos permita:

- Abrir la web del instituto.
- Llamar por tel√©fono al instituto.
- Ver la ubicaci√≥n del instituto en Google Maps.
- Enviar un correo electr√≥nico al instituto.
- Calcular la distancia desde nuestra ubicaci√≥n actual al instituto.
- Mandar un WhatsApp al instituto.

> [!NOTE]
> Esto en el emulador funcionar√° bastante regular, os recomiendo utilizar vuestro dispositivo f√≠sico.

Empecemos clonando el proyecto base desde GitHub: [https://github.com/scontreraslopez/IESSeveroOchoaIntents](https://github.com/scontreraslopez/IESSeveroOchoaIntents)

Partimos de una interfaz gr√°fica ya construida (Scaffold), pero los botones est√°n "muertos". Nuestro objetivo es conectarlos con el sistema operativo Android para que realicen acciones reales: llamar, abrir mapas, enviar correos y, lo m√°s complejo, **geolocalizar al usuario**.

Usaremos **Intents Impl√≠citos** (pedir al sistema que haga algo por nosotros) y gestionaremos **Permisos en tiempo de ejecuci√≥n** (la forma segura y moderna de pedir datos sensibles como la ubicaci√≥n).

### 1.3.1. Paso 0: Los cimientos (Configuraci√≥n)

Antes de tocar el c√≥digo Kotlin, necesitamos preparar el terreno. Si intentamos usar mapas o ubicaci√≥n sin avisar a Android, la app fallar√°.

**Dependencias (Gradle):**

Para calcular la ubicaci√≥n, no usamos la API antigua de Android, sino los **Google Play Services** (m√°s precisos y eficientes con la bater√≠a).
Ve al archivo `build.gradle.kts (Module: app)` y aseg√∫rate de a√±adir esta l√≠nea en el bloque `dependencies`:

```kotlin
implementation("com.google.android.gms:play-services-location:21.3.0")
```

> **Nota:** Al a√±adir esto, aparecer√° una barrita arriba diciendo "Sync Now". Acu√©rdate de pulsarla para que Gradle descargue la librer√≠a.

**El Manifiesto (Permisos y Visibilidad):**

Abre `AndroidManifest.xml`. Tenemos que hacer dos cosas aqu√≠:

1. **Declarar permisos de uso:** "Oye Android, mi app es capaz de usar el GPS".
2. **Declarar visibilidad (`queries`):** Desde Android 11, las apps no pueden ver qu√© otras apps hay instaladas (por privacidad). Si queremos saber si WhatsApp existe, debemos pedir permiso para "preguntar".

Copia esto justo encima de la etiqueta `<application ...>`:

```xml
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>

    <queries>
        <package android:name="com.whatsapp" />
        <package android:name="com.google.android.apps.maps" />
    </queries>
```

-----

### 1.3.2. Paso 1: Abrir Web (LocalUriHandler)

Empezamos con lo f√°cil. En **Jetpack Compose**, abrir una URL es trivial gracias a `LocalUriHandler`.
Sit√∫ate al principio de la funci√≥n `IESSeveroOchoaIntents()`, donde est√°n las variables. Ver√°s que ya tienes definido:

```kotlin
    val context = LocalContext.current
    val uriHandler = LocalUriHandler.current // El "mago" que abre enlaces
    val webUrl = "https://portal.edu.gva.es/03013224/"
```

- **¬øQu√© es `LocalUriHandler`?** Es una herramienta de Compose que sabe "despachar" URIs. Si le das una web, abre el navegador. Si le das un tel√©fono, abre el marcador.

Ahora, ve al bot√≥n **"Web del Instituto"** y en su `onClick` a√±ade:

```kotlin
    uriHandler.openUri(webUrl)
```

¬°Listo! Android detectar√° el prefijo `https://` y buscar√° un navegador (Chrome) para abrirlo.

-----

### 1.3.3. Paso 2: Llamada Telef√≥nica (El esquema `tel:`)

Continuamos con el bot√≥n de **Llamar**. Aqu√≠ vamos a usar el mismo `uriHandler`, pero el truco est√° en la cadena de texto que le pasamos.
Las URIs funcionan por **esquemas**.

- Web -\> `https://...`
- Tel√©fono -\> `tel:...`

Busca el bot√≥n **"Llamar a Secretar√≠a"** y a√±ade:

```kotlin
    // El formato debe ser "tel:+3496..."
    uriHandler.openUri("tel:$phoneNumber")
```

> **Detalle:** F√≠jate en el prefijo `tel:`. Sin √©l, Android intentar√≠a abrirlo como una web y fallar√≠a.

-----

### 1.3.4. Paso 3: Google Maps (Codificaci√≥n y Query Strings)

Aqu√≠ la cosa se pone interesante. Queremos abrir Google Maps centrado en el instituto, con el zoom adecuado y una chincheta (marcador) con nombre.

Los Intent de mapas son "especialitos". Tienen este formato:
`geo:0,0?q=latitud,longitud(Nombre de la etiqueta)&z=zoom`

1. **¬øPor qu√© `geo:0,0`?** Le decimos al mapa "no te centres en ninguna coordenada inicial, c√©ntrate en lo que venga en la b√∫squeda (`q`)".
2. **El problema de los espacios:** La etiqueta "IES Severo Ochoa" tiene espacios. Las URLs **odian** los espacios. Si mandamos eso tal cual, el enlace se rompe.

**Soluci√≥n:** Usar `URLEncoder`.

Ve al bot√≥n **"Ver en Google Maps"** y completa el `TODO`:

```kotlin
    // 1. Codificamos el nombre para que sea seguro (los espacios se convierten en %20, etc.)
    // IMPORTANTE: Necesitar√°s importar java.net.URLEncoder
    val encodedLabel = URLEncoder.encode(mapLabel, "UTF-8")

    // 2. Construimos la URI compleja concatenando las variables
    val geoUri = "geo:0,0?q=$latitude,$longitude($encodedLabel)&z=$mapZoom"

    // 3. Lanzamos
    uriHandler.openUri(geoUri)
```

Ahora, al pulsar, Maps entender√° perfectamente d√≥nde ir y qu√© nombre mostrar.

-----

### 1.3.5. Paso 4: Email (El esquema `mailto:`)

Enviar un correo es similar. Usamos el esquema `mailto:`. Pero cuidado, el asunto (`subject`) y el cuerpo (`body`) tambi√©n pueden tener espacios y tildes. ¬°Hay que codificarlos!

Ve al bot√≥n **"Enviar Email"** y a√±ade:

```kotlin
    // Codificamos asunto y cuerpo
    val encodedSubject = URLEncoder.encode(emailSubject, "UTF-8")
    val encodedBody = URLEncoder.encode(emailBody, "UTF-8")

    // Construimos la URI
    val mailtoUri = "mailto:$emailRecipient?subject=$encodedSubject&body=$encodedBody"

    uriHandler.openUri(mailtoUri)
```

-----

### 1.3.6. Paso 5: WhatsApp (Intents manuales y Excepciones)

A veces `uriHandler` se queda corto o queremos m√°s control. Para WhatsApp, vamos a implementar una funci√≥n auxiliar `sendWhatsAppMessage` al final del archivo.

**Reto:** ¬øQu√© pasa si el usuario NO tiene WhatsApp instalado? Si intentamos abrirlo sin m√°s, la app se cerrar√° de golpe (crash). Debemos controlar ese error.

Ve a la funci√≥n `sendWhatsAppMessage` (al final del archivo) e implem√©ntala as√≠:

```kotlin
fun sendWhatsAppMessage(context: Context, phoneNumber: String, message: String) {
    // 1. Limpieza: WhatsApp quiere el n√∫mero sin '+' ni espacios (ej: 34666...)
    val cleanNumber = phoneNumber.replace("+", "").replace(" ", "")
    
    // 2. Codificamos el mensaje
    val encodedMessage = URLEncoder.encode(message, "UTF-8")
    
    // 3. Creamos la URI "m√°gica" de WhatsApp
    val uri = "https://wa.me/$cleanNumber?text=$encodedMessage"

    // 4. Creamos un Intent nativo ACTION_VIEW
    val intent = Intent(Intent.ACTION_VIEW)
    intent.data = android.net.Uri.parse(uri)

    /* TRUCO PRO: Si descomentas la siguiente l√≠nea, obligas a abrir WhatsApp oficial.
       Si la dejas comentada, Android preguntar√° al usuario (√∫til si usa WhatsApp Business) */
    // intent.setPackage("com.whatsapp")

    // 5. INTENTAMOS abrir la actividad
    try {
        context.startActivity(intent)
    } catch (e: ActivityNotFoundException) {
        // Si entramos aqu√≠, es que no tiene WhatsApp instalado
        Toast.makeText(context, "WhatsApp no est√° instalado", Toast.LENGTH_SHORT).show()
    }
}
```

Ahora conecta esta funci√≥n en el bot√≥n **"Mandar Whatsapp"** del Scaffold.

-----

### 1.3.7. Paso 6: Ubicaci√≥n y Permisos (lo m√°s complejo)

Esta es la parte m√°s compleja. La ubicaci√≥n se considera un **permiso peligroso**. No basta con ponerlo en el Manifest; hay que pedirle permiso al usuario mediante una ventana emergente (di√°logo) mientras usa la app.

**El "Launcher" de Permisos:**

En Compose, necesitamos registrar un "lanzador" que escuche la respuesta del usuario (¬øDijo S√ç o dijo NO?).
Ve al inicio de `IESSeveroOchoaIntents`, busca el **TODO Paso 5. Crear el permissionLauncher** y a√±ade:

```kotlin
    // Preparamos el escuchador de permisos
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        // Este c√≥digo se ejecuta CUANDO el usuario responde al di√°logo
        val isGranted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                        permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true

        if (isGranted) {
            Toast.makeText(context, "Permiso concedido. Calculando...", Toast.LENGTH_SHORT).show()
            // ¬°Llamamos a la funci√≥n que calcula!
            calculateAndShowDistance(context, latitude, longitude)
        } else {
            Toast.makeText(context, "Se necesita permiso para calcular la distancia", Toast.LENGTH_LONG).show()
        }
    }
```

**Entendiendo `rememberLauncherForActivityResult` (El concepto clave)**

Hasta ahora, nuestro c√≥digo era lineal: puls√°bamos un bot√≥n y se abr√≠a una web. Fin.
Pero los **Permisos** son diferentes. Es una conversaci√≥n de dos v√≠as:

1. Tu App pregunta: "¬øPuedo usar el GPS?"
2. Tu App **se queda esperando**.
3. El Usuario decide (puede tardar 1 segundo o 10 minutos).
4. Android vuelve a tu App con la respuesta: "S√≠" o "No".

Para manejar esto en Compose, necesitamos "registrar" una oficina de recepci√≥n de respuestas antes de pedir nada. Eso es lo que hace `rememberLauncherForActivityResult`.

**Imagina que es como el "Busca" (Beeper) de los 100 Montaditos:**

- T√∫ llegas (se inicia la pantalla) y pides lo que quieres: Una de patatas 4 salsas, un 90...
- Pagas y el camarero te da un "Busca" (**creas el Launcher**).
- T√∫ te sientas a esperar.
- Cuando la mesa est√° lista, el aparato vibra y t√∫ reaccionas a por tus patatas (**se ejecuta el c√≥digo dentro de las llaves `{ }`**).

Vamos a hacer un forensics a este bloque de c√≥digo para entenderlo de verdad:

```kotlin
val permissionLauncher = rememberLauncherForActivityResult(
    contract = ActivityResultContracts.RequestMultiplePermissions()
) { permissions -> 
    // ... c√≥digo de respuesta ...
}
```

**1. `rememberLauncherForActivityResult`**:

  * **¬øQu√© es?**: Es una funci√≥n de Compose que "registra" nuestra petici√≥n al sistema operativo.
  * **¬øPor qu√© `remember`?**: En Compose, la pantalla se redibuja (recompone) constantemente. Si no us√°ramos `remember`, cada vez que la pantalla parpadeara, perder√≠amos la conexi√≥n con nuestra petici√≥n de permisos. Esto mantiene al "intermediario" vivo.

**2. `contract = ActivityResultContracts.RequestMultiplePermissions()`**:

  * **El Contrato**: Aqu√≠ le decimos a Android **qu√© tipo de tarea** vamos a hacer. No es lo mismo pedir "Hacer una foto" (`TakePicture`) que "Pedir Permisos" (`RequestMultiplePermissions`).
  * Al definir este contrato, Android ya sabe que cuando vuelva con la respuesta, debe traernos un mapa con los resultados de los permisos.

**3. `{ permissions -> ... }` (La Callback o "El Buz√≥n")**:

  * Todo lo que escribas entre estas llaves **NO se ejecuta ahora**.
  * Es el c√≥digo que se ejecutar√° **EN EL FUTURO**, justo en el momento en que el usuario pulse "Permitir" o "Denegar" en la ventana emergente.
  * **La variable `permissions`**: Es el cartero. Es un `Map` (un diccionario) que contiene los pares de:
      * *Clave:* El nombre del permiso (ej. `ACCESS_FINE_LOCATION`).
      * *Valor:* `true` (concedido) o `false` (denegado).

**¬øC√≥mo se usa despu√©s? (El bot√≥n):***

Una cosa es **contratar al mensajero** (lo que acabamos de hacer arriba) y otra es **mandarlo a trabajar**.

Ahora ve al bot√≥n **"Calcula distancia..."** y haz que lance la petici√≥n:

Por eso, el c√≥digo anterior se pone al principio de la funci√≥n, pero el "disparo" se hace en el bot√≥n:

```kotlin
// En el onClick del bot√≥n:
permissionLauncher.launch( // <--- ¬°A trabajar!
    arrayOf(
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION
    )
)
```

Al llamar a `.launch()`, es cuando realmente aparece la ventana emergente en la pantalla del usuario.

-----

### 1.3.8. La L√≥gica Matem√°tica (Google Play Services)

Por √∫ltimo, vamos a implementar la funci√≥n `calculateAndShowDistance` al final del archivo. Aqu√≠ es donde ocurre la magia de `LocationServices`.

> **Atenci√≥n:** Necesitar√°s importar muchas clases. Si sale en rojo, pulsa `Alt+Enter` e importa.
> `Priority` viene de `com.google.android.gms.location`. Ojo que muchas importaciones son ambiguas y toca decir, Locale por ejemplo viene de `java.util`.

```kotlin
private fun calculateAndShowDistance(context: Context, instituteLat: String, instituteLon: String) {
    // 1. Obtenemos el cliente de ubicaci√≥n de Google
    val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)

    // 2. IMPORTANTE: Aunque el usuario haya dicho "S√≠" antes, 
    // Android exige por seguridad volver a verificar el permiso antes de llamar a la API.
    if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {

        // 3. Pedimos la ubicaci√≥n ACTUAL
        // PRIORITY_HIGH_ACCURACY: Usa GPS (gasta m√°s bater√≠a, pero es exacto)
        fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, CancellationTokenSource().token)
            .addOnSuccessListener { userLocation: Location? ->
                if (userLocation != null) {
                    // A. Creamos la ubicaci√≥n del Instituto
                    val instituteLocation = Location("provider").apply {
                        latitude = instituteLat.toDouble()
                        longitude = instituteLon.toDouble()
                    }

                    // B. Calculamos la distancia (magia matem√°tica de Android)
                    val distanceInMeters = userLocation.distanceTo(instituteLocation)
                    val distanceInKm = distanceInMeters / 1000f

                    // C. Mostramos resultado
                    val msg = String.format(Locale.getDefault(), "Est√°s a %.2f km del instituto", distanceInKm)
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show()
                } else {
                    Toast.makeText(context, "No se pudo obtener la ubicaci√≥n (GPS desactivado?)", Toast.LENGTH_SHORT).show()
                }
            }
            .addOnFailureListener {
                Toast.makeText(context, "Error al obtener ubicaci√≥n", Toast.LENGTH_SHORT).show()
            }
    }
}
```

-----

**üîé Forense de C√≥digo: `calculateAndShowDistance`**

Esta funci√≥n es la encargada de hacer el trabajo sucio. Vamos a diseccionarla pieza a pieza porque aqu√≠ ocurren varias cosas "invisibles" que es vital entender. Muchas son espec√≠ficas de la API de Google Play Services, pero bueno trabajar con temas de ubicaci√≥n es relativamente com√∫n, por lo que las explicamos al detalle. No te asustes, es normal no acordarse de esto hasta que te toque hacerlo en un proyecto real, que sepas que puedes volver aqu√≠ a repasarlo o buscar en la documentaci√≥n oficial.

#### El Cliente Fusionado (`FusedLocationProviderClient`)

```kotlin
val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
```

- **¬øQu√© es esto?** Antiguamente, en Android ten√≠as que elegir: "¬øUso el GPS (preciso pero lento) o el Wi-Fi (r√°pido pero impreciso)?".
- **La soluci√≥n de Google:** El `FusedLocationProvider` es un "cerebro" inteligente. √âl decide autom√°ticamente qu√© sensores combinar (fusionar) para darte la mejor ubicaci√≥n posible ahorrando bater√≠a. Es la puerta de entrada a los servicios de ubicaci√≥n.

#### El Doble Check de Seguridad (`checkSelfPermission`)

```kotlin
if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) { ... }
```

- **La Pregunta:** *"¬øPero no hab√≠amos pedido ya el permiso en el bot√≥n anterior?"*
- **La Respuesta:** S√≠, pero **Android no se f√≠a**. El usuario podr√≠a haber minimizado la app, ido a Ajustes y quitado el permiso hace 5 segundos.
- **La Regla:** Siempre, justo antes de ejecutar una l√≠nea de c√≥digo que requiera permisos (`getCurrentLocation`), debes verificar si *siguen* concedidos. Si no pones este `if`, el compilador te marcar√° un error rojo (Lint Error) diciendo que es inseguro.

#### La Petici√≥n As√≠ncrona (`getCurrentLocation`)

```kotlin
fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, CancellationTokenSource().token)
```

Aqu√≠ pedimos la ubicaci√≥n. F√≠jate en dos detalles:

- **`PRIORITY_HIGH_ACCURACY`**: Le decimos: "Enciende el GPS, quiero precisi√≥n m√°xima".
- **`CancellationToken`**: Es un "token de cancelaci√≥n". Es obligatorio pasarlo. Sirve por si quisieras cancelar la petici√≥n a medias (por ejemplo, si el usuario cierra la app antes de que el sat√©lite responda), aunque aqu√≠ no lo usaremos activamente.

#### El Concepto de "Listener" (El que espera)

```kotlin
.addOnSuccessListener { userLocation: Location? -> ... }
```

Obtener la ubicaci√≥n **tarda tiempo** (milisegundos o segundos). No podemos detener la app esperando al sat√©lite (la pantalla se congelar√≠a).

- Por eso usamos un **Listener**: un bloque de c√≥digo que se ejecuta **cuando el dato est√° listo**.
- Le decimos a Android: *"Sigue con tu vida, y cuando tengas el dato, av√≠same ejecutando este bloque de c√≥digo"*.
  - **El potencial `null`**: F√≠jate que `userLocation` puede ser nulo (`?`). ¬øPor qu√©?
    - El GPS est√° apagado.
    - Est√°s en un t√∫nel.
    - El m√≥vil acaba de reiniciarse y a√∫n no sabe d√≥nde est√°.
    - Por eso es **obligatorio** el `if (userLocation != null)`.

#### Matem√°ticas Geod√©sicas (`distanceTo`)

Tranquilo, casi todo viene ya enlatado en funciones que hacen las matem√°ticas duras por nosotros. Ten en cuenta que el tema de la geometr√≠a de la Tierra es complejo (esf√©rica, elipsoide, etc.), a pesar de lo que algunos digan **NO es plana**, pero Android nos lo simplifica.

```kotlin
val instituteLocation = Location("manual").apply {
    latitude = instituteLat.toDouble()
    longitude = instituteLon.toDouble()
}
val distanceInMeters = userLocation.distanceTo(instituteLocation)
```

- **Crear un punto destino:** Para calcular la distancia, necesitamos dos puntos. El `userLocation` (que nos acaba de llegar) y el del instituto. Creamos un objeto `Location` manual meti√©ndole las coordenadas que ten√≠amos guardadas arriba.
- **`distanceTo`:** Esta funci√≥n es magia pura. Calcula la distancia en l√≠nea recta sobre la curvatura de la Tierra (usando f√≥rmulas complejas como la de Haversine, que calcula la distancia *ortodr√≥mica*, la m√°s corta entre dos puntos en una esfera y que NO es una l√≠nea recta en un plano) y nos devuelve el resultado en **metros**.

#### El Toque Final (Formato)

```kotlin
String.format(Locale.getDefault(), "Est√°s a %.2f km", distanceInKm)
```

- Convertimos metros a kil√≥metros dividiendo por 1000.
- Usamos `String.format` para que solo muestre 2 decimales (`%.2f`). Adem√°s, al usar `Locale.getDefault()`, si el m√≥vil est√° en Espa√±a usar√° una coma (`15,40 km`) y si est√° en EEUU usar√° un punto (`15.40 km`). ¬°Detalles de profesional\!

**Resumen Visual del Flujo:**

Para que que vosotros (y yo) podamos visualizarlo, el flujo de esta funci√≥n es:

1. **START** -> ¬øTengo herramienta `fused`?
2. **CHECK** -> ¬øSigo teniendo permiso?
3. **REQUEST** -> "Sat√©lite, dime d√≥nde estoy (Alta Precisi√≥n)".
4. **WAIT** -> ... (La app sigue funcionando) ...
5. **CALLBACK** ->  Aqu√≠ tienes la ubicaci√≥n (o null).
6. **CALCULATE** -> Distancia entre (Yo) y (Instituto).
7. **SHOW** -> Toast con el resultado (o el error).

-----

### 1.4. Conclusi√≥n

¬°Felicidades! Has creado una app que interact√∫a completamente con el ecosistema Android. Has aprendido a:

1. Comunicarte con otras apps (Maps, Tel√©fono, Navegador) usando **URIs**.
2. Gestionar errores cuando una app no existe (WhatsApp).
3. Implementar el flujo completo de **Permisos en Tiempo de Ejecuci√≥n** (solicitar, esperar respuesta, actuar).
4. Usar los **Google Play Services** para geolocalizaci√≥n.

### Recursos adicionales sobre Intents

[https://developer.android.com/training/basics/intents]
https://developer.android.com/courses/pathways/android-basics-compose-unit-5-pathway-1

## 2. Consumo de APIs REST con Retrofit y Coroutines

Vamos a seguir el codelab oficial de Google para aprender a consumir APIs REST usando Retrofit junto con Coroutines en un entorno de Jetpack Compose.

Realizaremos la **Unit 5: Connect to internet** [https://developer.android.com/courses/android-basics-compose/course](https://developer.android.com/courses/android-basics-compose/course)
Aqu√≠ se explica paso a paso c√≥mo configurar Retrofit, definir las interfaces de la API, manejar las respuestas y errores, y mostrar los datos en la UI usando Compose.

Para la parte de c√≥mo implementar un login, nos podemos apoyar en el siguiente codelab: [https://developers.google.com/learn/pathways/firebase-android-jetpack](https://developers.google.com/learn/pathways/firebase-android-jetpack) . En este caso, es suficiente con mirar seguir los 3 primeros m√≥dulos donde se cubren los conceptos b√°sicos de autenticaci√≥n con Firebase. Tanto el tema de **Flows** como el resto de cuestiones los dejaremos de momento fuera, ya que son temas avanzado que exceden el alcance de este curso b√°sico.

[Work in progress... pokeapi]
